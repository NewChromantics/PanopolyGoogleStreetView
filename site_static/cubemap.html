<!DOCTYPE html>
<html lang="en">
<head>
<title>panopo.ly</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<link rel="Stylesheet" href="panopoly.css" type="text/css">
<style>

#experiment {
	-webkit-perspective: 800px;
	-webkit-perspective-origin: 50% 500px;
	-moz-perspective: 800px;
	-moz-perspective-origin: 50% 500px;
	perspective: 800px;
	perspective-origin: 50% 500px;
}


#cube {
	position: relative;
	margin: 100px auto;
	height: 1000px;
	width: 1000px;
	-webkit-transition: -webkit-transform 0s linear;
	-webkit-transform-style: preserve-3d;
	-moz-transition: -moz-transform 0s linear;
	-moz-transform-style: preserve-3d;
	transition: transform 0s linear;
	transform-style: preserve-3d;
}

#cubeparent
{
	-webkit-transform-style: preserve-3d;
	-moz-transform-style: preserve-3d;
	transform-style: preserve-3d;
	/*
		when all translate z is 200....
		far face 1000
		near face 600
		middle z = near + ((far-near)/2) = 800
	 */
}

.face {
	position: absolute;
	height: 1000px;
	width: 1000px;
	padding: 0px;
	margin: 0px;
	font-size: 20px;
	line-height: 1em;
	color: #fff;
}

#cube .up  {
	-webkit-transform: rotateX(90deg) translateZ(500px);
	-moz-transform: rotateX(90deg) translateZ(500px);
	transform: rotateX(90deg) translateZ(500px);
	
	background-color: red;
}

#cube .front {
	-webkit-transform: translateZ(500px);
	-moz-transform: translateZ(500px);
	transform: translateZ(500px);

	background-color: lime;
}

#cube .left {
	-webkit-transform: rotateY(90deg) translateZ(500px);
	-moz-transform: rotateY(90deg) translateZ(500px);
	transform: rotateY(90deg) translateZ(500px);
	
	background-color: blue;
}

#cube .back {
	-webkit-transform: rotateY(180deg) translateZ(500px);
	-moz-transform: rotateY(180deg) translateZ(500px);
	transform: rotateY(180deg) translateZ(500px);
	
	background-color: yellow;
}

#cube .right {
	-webkit-transform: rotateY(-90deg) translateZ(500px);
	-moz-transform: rotateY(-90deg) translateZ(500px);
	transform: rotateY(-90deg) translateZ(500px);

	background-color: cyan;
}

#cube .down {
	-webkit-transform: rotateX(-90deg) rotate(180deg) translateZ(500px);
	-moz-transform: rotateX(-90deg) rotate(180deg) translateZ(500px);
	transform: rotateX(-90deg) rotate(180deg) translateZ(500px);

	background-color: magenta;
}


</style>
</head>

<body>
<div id="info">
	panopo.ly
</div>

<div id="TestContainer"></div>
<div id="UpTest">0</div>

<script src="js/soy.js"></script>
<script src="threejs/three.min.js"></script>
<script src="threejs/effects/StereoEffect.js"></script>
<script src="js/GoogleAnalytics.js"></script>
<script src="js/ClearDefaultText.js"></script>
<script src="js/SoyWebSocket-1.0.js"></script>
<script src="js/panopoly.js"></script>
<script src="js/support.js"></script>
<script src="js/SoySupport.js"></script>
<script src="js/SoyRiftWebsocket.js"></script>
<script src="js/SoySplit.js"></script>
<script src="js/SoyShrink.js"></script>
<script src="js/SoyFullscreen.js"></script>
<script src="js/SoyRiftAjax.js"></script>
<script src="js/SoyGyro.js"></script>
<script src="js/SoyCss3d.js"></script>
<script src="js/SoyFileSelect.js"></script>
<script src="js/SoyMouse.js"></script>



<div class="experiment-body clearfix">
    
	<div class="test test-3dtransforms">
<div id="experiment">
	
	<div id="cubeparent">
    <div id="cube">
		<div id="cube_up" class="face up">up</div>
		<div id="cube_front" class="face front">front</div>
		<div id="cube_left" class="face left">left</div>
		<div id="cube_back" class="face back">back</div>
		<div id="cube_right" class="face right">right</div>
		<div id="cube_down" class="face down">down</div>
    </div>
	</div>
	
</div>
    </div>
</div>

<script>
	
	//	if x & y angle == 0 then sides disapear... need to catch this case
	var xAngle = 0, yAngle = 0.001;
	var zTrans = 780;	//	center. Need to change this to account for fov
	var $TransformProperty = GetTransformProperty();

	function OnTransformChanged()
	{
		console.log("OnTransformChanged: " + zTrans );
		SetCameraRotation( xAngle, yAngle, 0 );
		var $ParentTransform = "translateZ("+zTrans+"px)";
		document.getElementById('cube').parentNode.style[$TransformProperty] = $ParentTransform;
	}
	OnTransformChanged();




function ascii (a) { return a.charCodeAt(0); }
	function OnKeyDown(evt)
	{
		switch(evt.keyCode) {
			case 37: // left
			yAngle -= 90;
			break;
			
			case 38: // up
			xAngle += 90;
			evt.preventDefault();
			break;
			
			case 39: // right
			yAngle += 90;
			break;
			
			case 40: // down
			xAngle -= 90;
			evt.preventDefault();
			break;
			
			case ascii('A'):
			zTrans += 50;
			evt.preventDefault();
			console.log(zTrans);
			break;

			case ascii('Z'):
			zTrans -= 50;
			evt.preventDefault();
			console.log(zTrans);
			break;
		};
		OnTransformChanged();
	}



function CubemapLayout($ImageUrl,$ImageWidth,$ImageHeight)
{
	this.mFront = new THREE.Vector2(3,1);
	this.mBack = new THREE.Vector2(1,1);
	this.mLeft = new THREE.Vector2(0,1);
	this.mRight = new THREE.Vector2(2,1);
	this.mUp = new THREE.Vector2(1,0);
	this.mDown = new THREE.Vector2(1,2);
	this.mBlockCount = new THREE.Vector2( 4, 3 );
	this.mImageUrl = $ImageUrl;
	this.mImageSize = new THREE.Vector2( $ImageWidth, $ImageHeight );
}

function ScaleVectors($a,$b)
{
	return new THREE.Vector2( $a.x * $b.x, $a.y * $b.y );
}

function DivideVectors($a,$b)
{
	return new THREE.Vector2( $a.x / $b.x, $a.y / $b.y );
}

CubemapLayout.prototype.GetFaceSize = function()	{	return DivideVectors( this.mImageSize, this.mBlockCount );	}
CubemapLayout.prototype.GetFront = function()	{	return ScaleVectors( this.mFront, this.GetFaceSize() );	}
CubemapLayout.prototype.GetBack = function()	{	return ScaleVectors( this.mBack, this.GetFaceSize() );	}
CubemapLayout.prototype.GetLeft = function()	{	return ScaleVectors( this.mLeft, this.GetFaceSize() );	}
CubemapLayout.prototype.GetRight = function()	{	return ScaleVectors( this.mRight, this.GetFaceSize() );	}
CubemapLayout.prototype.GetUp = function()		{	return ScaleVectors( this.mUp, this.GetFaceSize() );	}
CubemapLayout.prototype.GetDown = function()	{	return ScaleVectors( this.mDown, this.GetFaceSize() );	}

//	intialise cube faces
function SetCubemapBackground($Front,$Back,$Left,$Right,$Up,$Down)
{
//	var $Layout = new CubemapLayout('cubemap.jpg',400,300);
//	var $Layout = new CubemapLayout('cubemap2x.jpg',800,600);
	var $Layout = new CubemapLayout('stormycubemap.jpg',4096,3072);
/*
	var $Layout = new CubemapLayout('churchcubemap.jpg',8192, 2048);
	$Layout.mFront = new THREE.Vector2(2,0);
	$Layout.mBack = new THREE.Vector2(4,0);
	$Layout.mLeft = new THREE.Vector2(3,0);
	$Layout.mRight = new THREE.Vector2(1,0);
	$Layout.mUp = new THREE.Vector2(0,0);
	$Layout.mDown = new THREE.Vector2(5,0);
	$Layout.mBlockCount = new THREE.Vector2( 6, 1 );
*/

	
	SetFaceBackground( $Front, $Layout.GetFront(), $Layout );
	SetFaceBackground( $Back, $Layout.GetBack(), $Layout );
	SetFaceBackground( $Left, $Layout.GetLeft(), $Layout );
	SetFaceBackground( $Right, $Layout.GetRight(), $Layout );
	SetFaceBackground( $Up, $Layout.GetUp(), $Layout );
	SetFaceBackground( $Down, $Layout.GetDown(), $Layout );
}


function SetFaceBackground($Element,$ImageOffset,$Layout)
{
	var $ImageSize = $Layout.mImageSize;
	var $ImageUrl = $Layout.mImageUrl;
	if ( !$Element )
		return;
		
	var $FaceSize = new THREE.Vector2( $Element.clientWidth, $Element.clientHeight );
	var $CssScale = DivideVectors( $Layout.GetFaceSize(), $FaceSize );
	console.log	($Layout.GetFaceSize());
	console.log	($CssScale);
	var $x = -($ImageOffset.x/$CssScale.x) + 'px ';
	var $y = -($ImageOffset.y/$CssScale.y) + 'px ';
	var $w = ($ImageSize.x/$CssScale.x) + 'px ';
	var $h = ($ImageSize.y/$CssScale.y) + 'px ';
	
	
	$Element.style.background = 'url(' + $ImageUrl + ') ' + $x + $y;
	$Element.style.backgroundSize = $w + $h;
/*
 gr: setting these individually just didn't work...
	$Element.style.backgroundImage = 'url(' + $ImageUrl + ')';
	$Element.style.backgroundAttachment = "fixed";
	$Element.style.backgroundPosition = '-100px -0px';
	//$Element.style.backgroundSize = '' + $ImageSize.x + 'px ' + $ImageSize.y + 'px';
	//$Element.style.backgroundPosition = '' + $x + 'px ' + $y + 'px';
	//$Element.style.backgroundSize = '' + $ImageSize.x + 'px ' + $ImageSize.y + 'px';
	$Element.style.backgroundSize = '400px 300px';
*/
}



function SetCameraRotation($RotateX,$RotateY,$RotateZ)
{
	var $Transform = "rotateX("+$RotateX+"deg) rotateY("+$RotateY+"deg) rotateZ("+$RotateZ+"deg)";
	document.getElementById('cube').style[$TransformProperty] = $Transform;
	
}

function SetCameraQuaternion($Quaternion)
{
	//	convert quaternion to matrix
	var $Matrix = new THREE.Matrix4();
	$Matrix.makeRotationFromQuaternion( $Quaternion );
	
	//	doc's say css and three matrixes are column major... but doens't seem to be...
	$Matrix.getInverse($Matrix);

	//	convert matrix to css matrix
	//	according to https://developer.apple.com/library/safari/documentation/appleapplications/reference/SafariCSSRef/Articles/Functions.html
	//	this is column major
//	matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n)
	var $CssMatrix = 'matrix3d(';
	var $MatrixComponents = $Matrix.elements;
	for ( var $i=0;	$i<$MatrixComponents.length;	$i++)
	{
		if ( $i != 0 )
			$CssMatrix += ',';
		$CssMatrix += $MatrixComponents[$i];
	}
	$CssMatrix += ')';
	
	//	convert Quaternion to eular
	var $Transform = $CssMatrix;
	document.getElementById('cube').style[$TransformProperty] = $Transform;
}

function Update()
{
	//	update camera
	var Quaternion = GetCameraQuaternion();
	SetCameraQuaternion( Quaternion );
	
	var $UpdateRateMs = 1000/40;
	setTimeout( Update, $UpdateRateMs );
}


//	support callbacks
AddOnSupportedChangedListener('RiftWebsocket',	function($Supported){	CheckAutoSwitch('RiftWebsocket',$Supported);	} );
AddOnSupportedChangedListener('RiftAjax',		function($Supported){	CheckAutoSwitch('RiftAjax',$Supported);	} );
AddOnSupportedChangedListener('Gyro',			function($Supported){	CheckAutoSwitch('Gyro',$Supported);	} );
AddOnSupportedChangedListener('Mouse',			function($Supported){	CheckAutoSwitch('Mouse',$Supported);	} );



SetCubemapBackground( GetElement('cube_front'), GetElement('cube_back'), GetElement('cube_left'), GetElement('cube_right'), GetElement('cube_up'), GetElement('cube_down') );


//	init support
InitSupport();

//	save initial mode
PushMode();

Update();

/*
function AutoRotate()
{
	yAngle += 1;
	xAngle += 0.01;
	OnTransformChanged();
	setTimeout( AutoRotate, 1000/30 );
}
AutoRotate();
*/
//document.body.onkeydown = OnKeyDown;


</script>



</body>
</html>
