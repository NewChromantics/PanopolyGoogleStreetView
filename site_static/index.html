<!DOCTYPE html>
<html lang="en">
<head>
	<title>panopo.ly</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background:#3CF;
				padding:0;
				margin:0;
				font-weight: bold;
				overflow:hidden;
				font-family:Monospace;
				font-size:13px;
				color:#036;
				height:100%;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				color: #fff;
				padding: 5px;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				z-index:1000;
			}

			a {
				color: #ffffff;
			}
		
		#container
		{
			text-align: center;
			position: absolute;
			
			top: 0px;
			left:0px;
			bottom:0px;
			right:0px;
		}
		
		#container.ipad_smallviewport
		{
			top: auto;
			height: 55%;
			bottom:0px;
			left:10%;
			right:10%;
		}
		
		.FileInput, .Button
		{
			background: rgba( 255,255,255,0.4 );
			float:left;
			xxmargin-left:auto;
			margin-left:10px;
			margin-right:auto;
			margin-bottom: 10px;
			xxwidth:30%;
			visibility: hidden;	/*	all off by default*/
			border: dashed 3px #fff;
			padding:10px;
		}
		
		#uploader_submit
		{
			visibility: hidden;
		}

			#oldie a { color:#da0 }
		</style>
	</head>

	<body id="xxxcontainer">
		<div id="info">
			panopo.ly
			
			<div id="uploader" class="FileInput">
				Upload new sphereical image<br />
				<form id="uploaderform" enctype="multipart/form-data" method="POST">
					<!-- MAX_FILE_SIZE must precede the file input field -->
					<input type="hidden" name="xxxxMAX_FILE_SIZE" value="30000" />
					<!-- Name of input element determines name in $_FILES array -->
					<input id="image_selector" name="image" type="file" />
					<input id="uploader_submit" type="submit" value="Upload File" />
				</form>
			</div>
			
			<div id="ShrinkButton" class="Button" onClick="OnClickedShrink()">
				Shrink
			</div>
			<div id="SplitButton" class="Button" onClick="OnClickedSplit()">
				Stereo View
			</div>
		
		</div>

		<script src="js/three.min.js"></script>

		<script src="js/effects/StereoEffect.js"></script>
		
		<script src="js/controls/DeviceOrientationControls.js"></script>
	
		<div id="container"></div>


		<script>
			
			
			var container;
			
			var camera, scene, renderer, effect;
			
			var mesh, lightMesh, geometry;
			var spheres = [];
			
			var directionalLight, pointLight;
			
			
			var isUserInteracting = false;
			var onMouseDownMouseX = 0;
			var onMouseDownMouseY = 0;
			var lon = 0;
			var onMouseDownLon = 0;
			var lat = 0;
			var onMouseDownLat = 0;
			var phi = 0;
			var theta = 0;
			var UpdateList = [];	//	anything here gets .update() called
			
			var Gyro = null;
			var InputController = null;
		
		function GetUploadUrl()
		{
			return "http://localhost:8888/upload.php";
		}
		
		function ShowElement($ElementName,Visible)
		{
			if ( Visible == undefined )
				Visible = true;
			var Element = document.getElementById($ElementName);
			if ( !Element )
				return;
				Element.style.visibility = Visible ? "visible" : "hidden";
		}
		
		function OnClickedShrink()
		{
			var Container = document.getElementById("container");
			if ( !Container )
				return;
			if ( Container.className == "ipad_smallviewport" )
				Container.className = "";
			else
				Container.className = "ipad_smallviewport";
			onContainerResize();
		}
		
		function OnClickedSplit()
		{
			//	toggle stereo effect
			if ( effect )
			{
				effect = null;
				onContainerResize();
			}
			else
			{
				effect = new THREE.StereoEffect( renderer );
				effect.separation = 1;
				onContainerResize();
			}
			
		}
		
function CreateGyroControl()
{
	if ( !IsGyroSupported() )
		return false;

	Gyro = new THREE.Object3D();
	InputController = new THREE.DeviceOrientationControls( Gyro );
	InputController.connect();
	UpdateList.push( InputController );
	return true;
}
		


function GetCameraQuaternion()
{
	//	using gyro
	if ( Gyro )
		return Gyro.quaternion;
/*
	
	lat = Math.max( - 85, Math.min( 85, lat ) );
	phi = THREE.Math.degToRad( 90 - lat );
	theta = THREE.Math.degToRad( lon );
	
	 camera.target.x = 500 * Math.sin( phi ) * Math.cos( theta );
	 camera.target.y = 500 * Math.cos( phi );
	 camera.target.z = 500 * Math.sin( phi ) * Math.sin( theta );
	 */

/*
	var Origin = new THREE.Vector3(0,0,0);
	var Forward = new THREE.Vector3( 0, 0, 1 );
	var Up = new THREE.Vector3
	var Mat = new THREE.Matrix4();
	Mat.lookAt( Origin, Forward, Up );
	var Quat = new THREE.Quaternion();
	Quat.setFromRotationMatrix( Mat );
	//console.log(Quat);
	return Quat;
 */
	return camera.quaternion;
}


			function IsDevice(Name)
			{
				return ( navigator.userAgent.indexOf(Name) != -1 );
			}

			function AllowWebGl()
			{
				return true;
			}
			function HasWebGl()
			{
				if ( !AllowWebGl() )
					return false;
				
				if ( !window.WebGLRenderingContext )
					return false;
					
				//	could exist, but not enabled (iphone!)
				var canvas = document.createElement("canvas");
				var gl = null;
				var experimental = false;
				try			{	gl = canvas.getContext("webgl");	}
				catch ( e )	{	gl = null;	}

				//	do we have experimental?
				/*
				if ( !gl )
				{
					try { gl = canvas.getContext("experimental-webgl"); experimental = true; }
					catch (x) { gl = null; }
				}
				 */
				
				if (!gl)
					return false;
				return true;
			}
			function IsMobile()
			{
				if ( IsDevice('iPad') )
					return true;
				//return true;
				return !HasWebGl();
			}
			function IsSupported()
			{
				if ( HasWebGl() )
					return true;
				if ( !IsMobile() )
					return true;
				return false;
			}
		
			function GetPanoName()
			{
				//	extract from url;
				//	panopo.ly/#name
				var Name = window.location.hash;
				if ( !Name )
					Name = "Apartment11";
				return Name;
			}
			function GetPanoFilename()
			{
				var panoname = GetPanoName();
				return "http://image.panopo.ly/" + panoname + ".256.jpg";
			}
			function IsShrinkSupported()
			{
				return true;
				if ( IsDevice('iPad') )
					return true;
				return false;
			}
			function IsSplitSupported()
			{
				return true;
			}
			function IsFileUploadSupported()
			{
				if ( !IsSupported() )
					return false;
					
				//	does browser support input?
				if ( !window.File || !window.FileReader )
					return false;
					
				return true;
			}
		
			function IsGyroSupported()
			{
				//	gr: event supported... but assume not availible until we get a first event. so we need to create this regardless
				if ( !window.DeviceOrientationEvent )
					return false;
				
				if ( IsDevice('iPad') || IsDevice('iPhone') )
					return true;
				return false;
			}

		
			function handleFileSelect($Event)
			{
				var files = $Event.target.files; // FileList object
				
				var File = files[0];
				if ( !File )
					return;
				
				var reader = new FileReader();
				reader.onload = SetTexture;
				reader.readAsDataURL(File);
			}
		
			function SetTexture($Event)
			{
				var ImageData = $Event.target.result;
				
				console.log("ImageData");
				console.log( ImageData );
				
				var Material = mesh.material;
				console.log("mesh.material");
				console.log(mesh.material);
				if ( !Material )
					return;
					
				var image = document.createElement( 'img' );
				image.src = ImageData;
				Material.map = new THREE.Texture( image );
				Material.map.needsUpdate = true;
				Material.needsUpdate = true;
				
				//	image changed okay, enable upload
				ShowElement("uploader_submit", true );
			}
		
		
		
		
		
		
		
function ReplaceFilename(Filename,Number,NextNumber)
{
	var NewFilename = Filename.replace( Number.toString(), NextNumber.toString() );
	//console.log( NewFilename + " = " + Filename + " .replace( " + Number.toString() + " , " + NextNumber.toString() + ")" );
	if ( NewFilename == Filename )
		return null;
	return NewFilename;
}

function GetNextResFilename(Filename)
{
	var NewFilename = ReplaceFilename( Filename, 256, 1024 );
	if ( NewFilename )
		return NewFilename;

	if ( IsMobile() )
		return null;
	NewFilename = ReplaceFilename( Filename, 1024, 4096 );
	if ( NewFilename )
		return NewFilename;
	return null;
}
			
		function LoadHigher(Material)
		{
			if ( !Material.map )
				return;
			//console.log("LoadHigher - " + Material.map.sourceFile );
			var NewFilename = GetNextResFilename( Material.map.sourceFile );
			if ( NewFilename == null )
			{
				//console.log("no higher res");
				return;
			}
			console.log("loading higher res:" + NewFilename );
			
			var loader = new THREE.ImageLoader();
			var HiTexture = THREE.ImageUtils.loadTexture( NewFilename,
														 new THREE.UVMapping(),
														 function(NewHiTexture)
														 {
															Material.map = NewHiTexture;
															Material.needsUpdate = true;
															LoadHigher( Material );
														 },
														 function ()
														 {
															LoadHigher( Material );
														 }
														 );
		}
		

			function init(container) {
		/*
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'mouseup', onDocumentMouseUp, false );
				document.addEventListener( 'mousewheel', onDocumentMouseWheel, false );
				document.addEventListener( 'DOMMouseScroll', onDocumentMouseWheel, false);
*/
				var fov = 75;
				camera = new THREE.PerspectiveCamera( fov, 1, 1, 1000 );
				camera.target = new THREE.Vector3( 0, 0, 0 );
			
				scene = new THREE.Scene();

				var WidthSegments = 60;
				var HeightSegments = 40;
				if ( IsMobile() )
				{
					WidthSegments /= 2;
					HeightSegments /= 2;
				}
				var Size = 5;
				var geometry = new THREE.SphereGeometry( Size, WidthSegments, HeightSegments );
				//var geometry = new THREE.BoxGeometry( Size, Size, Size );
				geometry.applyMatrix( new THREE.Matrix4().makeScale( -1, 1, 1 ) );

				var Texture = THREE.ImageUtils.loadTexture( GetPanoFilename(), new THREE.UVMapping() );
				
				var material = new THREE.MeshBasicMaterial( {
														   map: Texture,
														   color: "white",
														   wireframe: false
										   } );
				LoadHigher( material );
				
	
				mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );
			
			
				if ( HasWebGl() )
					renderer = new THREE.WebGLRenderer();
				else
					renderer = new THREE.CanvasRenderer();
				renderer.setClearColor( 0xFF0000, 1);
				container.appendChild( renderer.domElement );

				onContainerResize();
				window.addEventListener( 'resize', onContainerResize, false );
				animate();
			}

			function onContainerResize()
			{
				var Container = renderer.domElement.parentNode;
				var w = Container.clientWidth;
				var h = Container.clientHeight;

				camera.aspect = w / h;
				camera.updateProjectionMatrix();

				if ( effect )
					effect.setSize( w, h );
				else
					renderer.setSize( w, h );

			}

			//

			function animate() {

				requestAnimationFrame( animate );
				
				UpdateList.forEach( function(it) {	it.update();	} );

				render();
			}

			function render() {

				var timer = 0.0001 * Date.now();

				if ( isUserInteracting === false ) {
					lon += 0.1;
				}
				
				//	update camera
				camera.quaternion.copy( GetCameraQuaternion() );

				if ( effect )
					effect.render( scene, camera );
				else
					renderer.render( scene, camera );

			}
		
		function onDocumentMouseDown( event ) {
			
			event.preventDefault();
			
			isUserInteracting = true;
			
			onPointerDownPointerX = event.clientX;
			onPointerDownPointerY = event.clientY;
			
			onPointerDownLon = lon;
			onPointerDownLat = lat;
			
		}
		
		function onDocumentMouseMove( event ) {
			
			//	mouseX = ( event.clientX - windowHalfX ) * 10;
			//	mouseY = ( event.clientY - windowHalfY ) * 10;
			
			if ( isUserInteracting === true ) {
				
				lon = ( onPointerDownPointerX - event.clientX ) * 0.1 + onPointerDownLon;
				lat = ( event.clientY - onPointerDownPointerY ) * 0.1 + onPointerDownLat;
				
			}
			
		}
		
		function onDocumentMouseUp( event ) {
			
			isUserInteracting = false;
			
		}
		
		function onDocumentMouseWheel( event ) {
			
			// WebKit
			
			if ( event.wheelDeltaY ) {
				
				camera.fov -= event.wheelDeltaY * 0.05;
				
				// Opera / Explorer 9
				
			} else if ( event.wheelDelta ) {
				
				camera.fov -= event.wheelDelta * 0.05;
				
				// Firefox
				
			} else if ( event.detail ) {
				
				camera.fov += event.detail * 1.0;
				
			}
			
			camera.updateProjectionMatrix();
			
		}
		
		</script>
		
		
		<script>
		//	main
		var Info = document.getElementById("info");
		if ( Info )
		{
			/*
			Info.innerText += " | " + navigator.userAgent;
			if ( HasWebGl() )
				Info.innerText += " | has webgl";
			else
				Info.innerText += " | no webgl";
			 */
		}
		
		if ( IsShrinkSupported() )
		{
			ShowElement("ShrinkButton");
		}
		
		if ( IsSplitSupported() )
		{
			ShowElement("SplitButton");
		}
		
		//	enable uploader for ipad
		if ( IsFileUploadSupported() )
		{
			var Uploader = document.getElementById("image_selector");
			var UploaderForm = document.getElementById("uploaderform");
			if ( Uploader && UploaderForm )
			{
				ShowElement("uploader",true);
				Uploader.addEventListener('change', handleFileSelect, false);
				UploaderForm.action = GetUploadUrl();
			}
		}


		var Container = document.getElementById("container");
		if ( IsSupported() )
		{
			init( Container );
		}
		else
		{
			var Container = document.getElementById("container");
			Container.style.padding = "20%";
			Container.innerText = "Not currently supported with webgl. Get the AppStore app.";
		}
		
		CreateGyroControl();
		
		</script>

	</body>
</html>
