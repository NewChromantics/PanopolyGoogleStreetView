<!DOCTYPE html>
<html lang="en">
<head>
	<title>panopo.ly</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel="Stylesheet" href="panopoly.css" type="text/css">
</head>

	<body id="xxxcontainer">
		<div id="info">
			panopo.ly
			<div id="UpTest" class="Button">0</div>

			<div id="ImageSelector" class="FileInput">
				Select Image
				<form id="uploaderform" enctype="multipart/form-data" method="POST">
					<input id="image_selector" name="image" type="file" />
				</form>
			</div>
			
			<div id="ImageUploader" class="FileInput">
				Upload Image<br />
				<input type="text" id="ImageUploader_CustomName" name="CustomName" class="cleardefault" value="custom url" />
				<input type="button" value="Upload File"  onclick="UploadImage()"/>
				<progress id="progressBar" value="0" max="100" style="width:300px;"></progress>
				<h3 id="status"></h3>
				<p id="loaded_n_total"></p>
			</div>
			
			<div id="ShrinkButton" class="Button" onClick="SupportToggleEnable('Shrink')">
				Shrink
			</div>
			<div id="SplitButton" class="Button" onClick="SupportToggleEnable('Split')">
				Stereo View
			</div>
			
			<div id="RiftWebsocketButton" class="Button" onClick="SupportToggleEnable('RiftWebsocket')">
				Rift Websocket
			</div>
			
			<div id="RiftAjaxButton" class="Button" onClick="SupportToggleEnable('RiftAjax')">
				Rift Ajax
			</div>
			
			<div id="FullscreenButton" class="Button" onClick="SupportToggleEnable('Fullscreen')">
				Fullscreen
			</div>
			
			<div id="GyroButton" class="Button" onClick="SupportToggleEnable('Gyro')">
				Gyro
			</div>
			
			<div id="QuatDebug" class="Button" style="display:block;">
				quaternion
			</div>
			
		</div>

		<script src="js/soy.js"></script>
		<script src="threejs/three.min.js"></script>
		<script src="threejs/effects/StereoEffect.js"></script>
		<script src="js/MouseControls.js"></script>
		<script src="js/GoogleAnalytics.js"></script>
		<script src="js/ClearDefaultText.js"></script>
		<script src="js/SoyWebSocket-1.0.js"></script>
		<script src="js/panopoly.js"></script>
		<script src="js/support.js"></script>
		<script src="js/SoySupport.js"></script>
		<script src="js/SoyRiftWebsocket.js"></script>
		<script src="js/SoySplit.js"></script>
		<script src="js/SoyShrink.js"></script>
		<script src="js/SoyFullscreen.js"></script>
		<script src="js/SoyRiftAjax.js"></script>
		<script src="js/SoyGyro.js"></script>
	
		<div id="container"></div>


<script>

function SoyMode($CameraControl)
{
	this.mCameraControl = $CameraControl;
	this.mSplit = IsSupportEnabled('Split');
	this.mFullscreen = IsSupportEnabled('Fullscreen');
}

//	current control
var $CurrentCameraControl = null;
//	previous modes
var $ModeStack = new Array();

//	auto-switch modesets
var $DesktopRiftMode = new Array('RiftAjax','Split');
//var $IosExternalMode = new Array('Gyro','Split','ExternalDisplay');
var $IosExternalMode = new Array('Gyro','Split');



//	save current mode
function PushMode()
{
	var $CurrentMode = new SoyMode($CurrentCameraControl);
	$ModeStack.push( $CurrentMode );
}

//	restore last mode
function PopMode($SpecificMode)
{
	//	pop last
	var $Last = $ModeStack.length-1;
	if ( $Last < 0 )
		return false;

	var $LastMode = $ModeStack[$Last];

	//	if specified, only pop if in certain mode
	if ( $SpecificMode )
		if ( $LastMode.mCameraControl != $SpecificMode )
			return false;
	
	$ModeStack.splice($Last);
	
	//	restore settings
	$CurrentCameraControl = $LastMode.mCameraControl;
	SetSupportEnabled('Split',$LastMode.mSplit);
	SetSupportEnabled('Fullscreen',$LastMode.mFullscreen);
	return true;
}


function TryMode($ModeParams,$ModeName)
{
	var $InModeNow = true;
	for ( var $Key in $ModeParams )
	{
		var $Support = GetSupport( $ModeParams[$Key] );
		if ( !$Support )
			return false;
		if ( !$Support.IsSupported() )
			return false;
		if ( !$Support.IsEnabled() )
			$InModeNow = false;
	}
	
	//	alraedy in mode
	if ( $InModeNow )
	{
		//alert("already in mode " + $ModeName );
		return true;
	}

	//	save current state
	PushMode();
	
	//	all supported, try and switch
	for ( var $Key in $ModeParams )
	{
		var $SupportName = $ModeParams[$Key];
		if ( !SetSupportEnabled( $SupportName ) )
		{
			//alert("failed to enable " + $SupportName );
			PopMode();
			return false;
		}
	}
	//	and set controller
	$CurrentCameraControl = $ModeParams[0];

	//alert("set mode " + $ModeName );
	return true;
}

function CheckAutoSwitch($ChangedSupport,$Supported)
{
	//	support was lost, if it's the current control, drop out of mode
	if ( !$Supported )
	{
		while ( $CurrentCameraControl == $ChangedSupport )
			if ( !PopMode( $ChangedSupport ) )
				break;
		return;
	}
	
	//	something became enabled, try the different modes
	TryMode( $DesktopRiftMode, "DesktopRift" );
	TryMode( $IosExternalMode, "IosGyro" );
}

	
function OnRiftWebsocketSupportChanged($Supported)
{
	ShowElement('RiftWebsocketButton', $Supported);
	CheckAutoSwitch( 'RiftWebsocket', $Supported );
}

function OnRiftAjaxSupportChanged($Supported)
{
	ShowElement('RiftAjaxButton', $Supported);
	CheckAutoSwitch( 'RiftAjax', $Supported );
}

function OnSplitSupportChanged($Supported)
{
	ShowElement('SplitButton', $Supported);
	CheckAutoSwitch( 'Split', $Supported );
}

function OnShrinkSupportChanged($Supported)
{
	ShowElement('ShrinkButton', $Supported);
	CheckAutoSwitch( 'Shrink', $Supported );
}

function OnFullscreenSupportChanged($Supported)
{
	ShowElement('FullscreenButton', $Supported);
	CheckAutoSwitch( 'Fullscreen', $Supported );
}

function OnGyroSupportChanged($Supported)
{
	ShowElement('GyroButton', $Supported);
	CheckAutoSwitch( 'Gyro', $Supported );
}


//	support callbacks
AddOnSupportedChangedListener('RiftWebsocket', OnRiftWebsocketSupportChanged );
AddOnSupportedChangedListener('RiftAjax', OnRiftAjaxSupportChanged );
AddOnSupportedChangedListener('Split', OnSplitSupportChanged );
AddOnSupportedChangedListener('Shrink', OnShrinkSupportChanged );
AddOnSupportedChangedListener('Fullscreen', OnFullscreenSupportChanged );
AddOnSupportedChangedListener('Gyro', OnGyroSupportChanged );


//	scene
var camera, scene, renderer, effect;
var mesh, lightMesh, geometry;
var spheres = [];
var directionalLight, pointLight;


var Gyro = null;
var InputController = null;
var UpdateList = [];	//	anything here gets .update() called

		function OnFileUploadSupported($Enable)
		{
			//	image binary loaded okay, enable upload
			ShowElement("ImageUploader", $Enable );
		}
		
		function UploadImage()
		{
			GetElement("progressBar").value = 0;
			GetElement("status").innerHTML = "";

			var formdata = new FormData();
			var file = GetElement("image_selector").files[0];
			//alert(file.name+" | "+file.size+" | "+file.type);
			formdata.append("image", file);
			var defaultcustomname = GetElement("ImageUploader_CustomName").defaultText;
			var customname = GetElement("ImageUploader_CustomName").value;
			if ( customname != defaultcustomname )
				formdata.append("customname", customname );
			var ajax = new XMLHttpRequest();
			ajax.upload.addEventListener("progress", OnUploadProgress, false);
			ajax.addEventListener("load", OnUploadComplete, false);
			ajax.addEventListener("error", OnUploadError, false);
			ajax.addEventListener("abort", OnUploadAbort, false);
			ajax.open("POST", GetUploadUrl() );
			//ajax.setRequestHeader('Content-Type', 'multipart/form-data;');
			ajax.send(formdata);
		}

		function OnUploadProgress(event)
		{
			GetElement("loaded_n_total").innerHTML = "Uploaded "+event.loaded+" bytes of "+event.total;
			var percent = (event.loaded / event.total) * 100;
			GetElement("progressBar").value = Math.round(percent);
			GetElement("status").innerHTML = Math.round(percent)+"% uploaded... please wait";
		}

		function OnUploadError($Event)
		{
			var $Error = "Unknown error";
			if ( $Event.error != undefined )
				$Error = $Event.error;
			GetElement("status").innerHTML = "Upload Failed: " + $Error;
		}

		function OnUploadAbort(event)
		{
			var $Event = {};
			$Event.error = "Upload Aborted";
			OnUploadError($Event);
		}
		
		function OnUploadComplete($Event)
		{
			//	decode response
			var $Json = {};
			try
			{
				$Json = JSON.parse(event.target.responseText);
			}
			catch ( e )
			{
				$Json.error = "Error parsing response from server " + e.message;
			}
			
			if ( $Json.error )
			{
				var $Event = {};
				$Event.error = $Json.error;
				OnUploadError($Event);
				return;
			}
			var $Url = window.location + "#" + $Json.panoname;
			GetElement("status").innerHTML = 'Your new url is <a href="' + $Url + '">' + $Url + '</a>';
		}

		function OnClickedShrink()
		{
			EnableShrink( !IsShrinkEnabled() );
		}

		function OnClickedSplit()
		{
			EnableSplit( !IsSplitMode() );
		}

function OnClickedRiftMode()
{
	if ( !IsRiftModeSupported() )
		return false;
		
	var OldFullscreen = IsFullscreen();
	var OldSplitMode = IsSplitMode();
	
	//	go full screen
	if ( !SetFullscreen(true) )
		return false;
	
	//	enable split mode
	if ( !SetSplitMode(true) )
	{
		SetFullscreen(OldFullscreen);
		return false;
	}
	
	//	use rift control
	if ( !CreateRiftControl() )
	{
		SetFullscreen(OldFullscreen);
		SetSplitMode(OldSplitMode);
		return false;
	}
	
	return true;
}

function DeleteControl()
{
	Gyro = null;
	if ( InputController && InputController.disconnect != undefined )
		InputController.disconnect();
	removeFromArray( UpdateList, InputController );
	InputController = null;
}


function CreateMouseControl($Container)
{
	//	"has mouse" ?
	Gyro = new THREE.Object3D();
	InputController = new THREE.MouseOrientationControls( Gyro, $Container );
	InputController.connect();
	UpdateList.push( InputController );
	return true;
}
	
function GetCameraQuaternion()
{
	var $Control = GetSupport($CurrentCameraControl);
	if ( $Control && $Control.IsEnabled() )
	{
		return $Control.mQuaternion;
	}
	
	return camera.quaternion;
}




			function GetPanoName()
			{
				//	extract from url;
				//	panopo.ly/#name
				var Name = window.location.hash;
				if ( !Name )
					Name = "Apartment11";
				
				//	assume this might not be the case on all browsers, but chrome's .hash starts with an octothorpe
				if ( Name[0] == '#' )
					Name = Name.substr(1);
				
				return Name;
			}


			function OnFileSelect($Event)
			{
				var files = $Event.target.files; // FileList object
				
				var File = files[0];
				if ( !File )
					return;

				//	get image as datauri for texture
				var DataUriReader = new FileReader();
				DataUriReader.onload = SetTexture;
				DataUriReader.readAsDataURL(File);
			}
		
			function SetTextureFromData($Data)
			{
				var Material = mesh.material;
				if ( !Material )
					return false;
				
				var image = document.createElement( 'img' );
				image.src = $Data;
				Material.map = new THREE.Texture( image );
				Material.map.needsUpdate = true;
				Material.needsUpdate = true;
				return true;
			}
		
			function SetTexture($Event)
			{
				var ImageData = $Event.target.result;
				
				if ( SetTextureFromData( ImageData ) )
					OnFileUploadSupported(true);
			}
		
		
function LoadPano()
{
	var PanoName = GetPanoName();
	if ( PanoName == false )
		return false;

	var Material = mesh.material;
	if ( !Material )
		return false;
		
	//	0 is our magic "not loaded" res
	var Url = "http://image.panopo.ly/" + PanoName + ".0.jpg";
	//	do initial load
	Material.map.sourceFile = Url;
	console.log("loading " + PanoName);
	
	//	replace
	return LoadHigher( Material );
}
		
	
	

			function init($Container) {
		
				var fov = 75;
				camera = new THREE.PerspectiveCamera( fov, 1, 1, 1000 );
				camera.target = new THREE.Vector3( 0, 0, 0 );
			
				scene = new THREE.Scene();

				var WidthSegments = 60;
				var HeightSegments = 40;
				if ( IsMobile() )
				{
					WidthSegments /= 2;
					HeightSegments /= 2;
				}
				var Size = 5;
				var geometry = new THREE.SphereGeometry( Size, WidthSegments, HeightSegments );
				//var geometry = new THREE.BoxGeometry( Size, Size, Size );
				geometry.applyMatrix( new THREE.Matrix4().makeScale( -1, 1, 1 ) );

				//	load default texture
				var Texture = THREE.ImageUtils.loadTexture( GetDefaultPanoFilename(), new THREE.UVMapping() );
				var material = new THREE.MeshBasicMaterial( {
														   map: Texture,
														   color: "white",
														   wireframe: false
										   } );
				LoadHigher( material );
				
	
				mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );
			
			
				if ( HasWebGl() )
					renderer = new THREE.WebGLRenderer();
				else
					renderer = new THREE.CanvasRenderer();
				renderer.setClearColor( 0xFF0000, 1);
				$Container.appendChild( renderer.domElement );

				onContainerResize();
				window.addEventListener( 'resize', onContainerResize, false );
				animate();
			}

			function onContainerResize()
			{
				var Container = renderer.domElement.parentNode;
				var w = Container.clientWidth;
				var h = Container.clientHeight;

				camera.aspect = w / h;
				camera.updateProjectionMatrix();

				if ( effect )
					effect.setSize( w, h );
				else
					renderer.setSize( w, h );

			}

			//

			function animate() {

				requestAnimationFrame( animate );
				
				UpdateList.forEach( function(it) {	it.update();	} );

				render();
			}

			function render() {

				var timer = 0.0001 * Date.now();

				//	update camera
				var Quaternion = GetCameraQuaternion();
				camera.quaternion.copy( Quaternion );
				
				var QuatDebugElement = GetElement("QuatDebug");
				if ( QuatDebugElement )
					QuatDebugElement.innerText = $CurrentCameraControl + ": " + Quaternion.x + " " + Quaternion.y + " " + Quaternion.z + " " + Quaternion.w;
				
				if ( effect )
					effect.render( scene, camera );
				else
					renderer.render( scene, camera );
			}
	
		
		</script>
		
		
		<script>
		
		//	main
		
		function UpdateUpTest()
		{
			ShowElement("UpTest");
			var Container = GetElement("UpTest");
			if ( !Container )
				return;
			Container.innerText = parseInt( Container.innerText ) + 1;
			setTimeout( UpdateUpTest, 1000 );
		}
		UpdateUpTest();


		//	init support
		InitSupport();
		//	save initial mode
		PushMode();



		
		var Container = GetElement("container");
		if ( HasWebGl() || !IsMobile() )
		{
			
			init( Container );
			
			CreateMouseControl(Container);

			//	load user's required pano
			LoadPano();
		}
		else
		{
			var Container = document.getElementById("container");
			Container.style.padding = "20%";
			Container.innerText = "Not currently supported without webgl.";
			
		}


			</script>

	</body>
</html>
