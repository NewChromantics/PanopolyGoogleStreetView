<!DOCTYPE html>
<html lang="en">
<head>
	<title>panopo.ly</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background:#3CF;
				padding:0;
				margin:0;
				font-weight: bold;
				overflow:hidden;
				font-family:Monospace;
				font-size:13px;
				color:#036;
				height:100%;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				color: #fff;
				padding: 5px;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				z-index:1000;
			}

			a {
				color: #ffffff;
			}
		
		#container
		{
			text-align: center;
			position: absolute;
			
			top: 0px;
			left:0px;
			bottom:0px;
			right:0px;
		}
		
		#container.ipad_smallviewport
		{
			top: auto;
			height: 55%;
			bottom:0px;
			left:10%;
			right:10%;
		}
		
		.FileInput
		{
			margin-left:auto;
			margin-right:auto;
			width:30%;
			visibility: none;	/*	all off by default*/
			border: dashed 3px #fff;
			padding:10px;
		}

			#oldie a { color:#da0 }
		</style>
	</head>

	<body id="xxxcontainer">
		<div id="info">
			panopo.ly
			
			<div id="uploader" class="FileInput">
				Upload new sphereical image<br />
				<input type="file" id="files" name="files" />
			</div>
		
		</div>

		<script src="js/three.min.js"></script>

		<script src="js/effects/StereoEffect.js"></script>
		
		<script src="js/controls/DeviceOrientationControls.js"></script>
	
		<div id="container"></div>


		<script>
			
			
			var container;
			
			var camera, scene, renderer, effect;
			
			var mesh, lightMesh, geometry;
			var spheres = [];
			
			var directionalLight, pointLight;
			
			
			var isUserInteracting = false;
			var onMouseDownMouseX = 0;
			var onMouseDownMouseY = 0;
			var lon = 0;
			var onMouseDownLon = 0;
			var lat = 0;
			var onMouseDownLat = 0;
			var phi = 0;
			var theta = 0;
			
			
function GetForward()
{
	/*
	
	lat = Math.max( - 85, Math.min( 85, lat ) );
	phi = THREE.Math.degToRad( 90 - lat );
	theta = THREE.Math.degToRad( lon );
	
	 camera.target.x = 500 * Math.sin( phi ) * Math.cos( theta );
	 camera.target.y = 500 * Math.cos( phi );
	 camera.target.z = 500 * Math.sin( phi ) * Math.sin( theta );
	 */

	return new THREE.Vector3( 0, 0, 1 );
}


			function IsDevice(Name)
			{
				return ( navigator.userAgent.indexOf(Name) != -1 );
			}
			function IsStereoView()
			{
				return true;
			}
			function AllowWebGl()
			{
				return true;
			}
			function HasWebGl()
			{
				if ( !AllowWebGl() )
					return false;
				
				if ( !window.WebGLRenderingContext )
					return false;
					
				//	could exist, but not enabled (iphone!)
				var canvas = document.createElement("canvas");
				var gl = null;
				var experimental = false;
				try			{	gl = canvas.getContext("webgl");	}
				catch ( e )	{	gl = null;	}

				//	do we have experimental?
				/*
				if ( !gl )
				{
					try { gl = canvas.getContext("experimental-webgl"); experimental = true; }
					catch (x) { gl = null; }
				}
				 */
				
				if (!gl)
					return false;
				return true;
			}
			function IsMobile()
			{
				if ( IsDevice('iPad') )
					return true;
				//return true;
				return !HasWebGl();
			}
			function IsSupported()
			{
				if ( HasWebGl() )
					return true;
				if ( !IsMobile() )
					return true;
				return false;
			}
			function GetPanoFilename()
			{
				return "panos/Apartment11_256.jpg";
			}
			function EnableFileUploader()
			{
				if ( !IsSupported() )
					return false;
					
				//	does browser support input?
				if ( !window.File || !window.FileReader )
					return false;
					
				return true;
			}
		
			function handleFileUpload($Event)
			{
				var files = $Event.target.files; // FileList object
				
				var File = files[0];
				if ( !File )
					return;
				
				var reader = new FileReader();
				reader.onload = SetTexture;
				reader.readAsDataURL(File);
			}
		
			function SetTexture($Event)
			{
				var ImageData = $Event.target.result;
				
				console.log("ImageData");
				console.log( ImageData );
				
				var Material = mesh.material;
				console.log("mesh.material");
				console.log(mesh.material);
				if ( !Material )
					return;
					
				var image = document.createElement( 'img' );
				image.src = ImageData;
				Material.map = new THREE.Texture( image );
				Material.map.needsUpdate = true;
				Material.needsUpdate = true;
			}
		
		
		
		
		
		
		
function ReplaceFilename(Filename,Number,NextNumber)
{
	var NewFilename = Filename.replace( Number.toString(), NextNumber.toString() );
	//console.log( NewFilename + " = " + Filename + " .replace( " + Number.toString() + " , " + NextNumber.toString() + ")" );
	if ( NewFilename == Filename )
		return null;
	return NewFilename;
}

function GetNextResFilename(Filename)
{
	var NewFilename = ReplaceFilename( Filename, 256, 1024 );
	if ( NewFilename )
		return NewFilename;

	if ( IsMobile() )
		return null;
	NewFilename = ReplaceFilename( Filename, 1024, 4096 );
	if ( NewFilename )
		return NewFilename;
	return null;
}
			
		function LoadHigher(Material)
		{
			if ( !Material.map )
				return;
			//console.log("LoadHigher - " + Material.map.sourceFile );
			var NewFilename = GetNextResFilename( Material.map.sourceFile );
			if ( NewFilename == null )
			{
				//console.log("no higher res");
				return;
			}
			console.log("loading higher res:" + NewFilename );
			
			var loader = new THREE.ImageLoader();
			var HiTexture = THREE.ImageUtils.loadTexture( NewFilename,
														 new THREE.UVMapping(),
														 function(NewHiTexture)
														 {
															Material.map = NewHiTexture;
															Material.needsUpdate = true;
															LoadHigher( Material );
														 },
														 function ()
														 {
															LoadHigher( Material );
														 }
														 );
		}
		

			function init(container) {
		/*
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'mouseup', onDocumentMouseUp, false );
				document.addEventListener( 'mousewheel', onDocumentMouseWheel, false );
				document.addEventListener( 'DOMMouseScroll', onDocumentMouseWheel, false);
*/
				var fov = 75;
				camera = new THREE.PerspectiveCamera( fov, 1, 1, 1000 );
				camera.target = new THREE.Vector3( 0, 0, 0 );
			
				scene = new THREE.Scene();

				var WidthSegments = 60;
				var HeightSegments = 40;
				if ( IsMobile() )
				{
					WidthSegments /= 2;
					HeightSegments /= 2;
				}
				var Size = 5;
				var geometry = new THREE.SphereGeometry( Size, WidthSegments, HeightSegments );
				//var geometry = new THREE.BoxGeometry( Size, Size, Size );
				geometry.applyMatrix( new THREE.Matrix4().makeScale( -1, 1, 1 ) );

				var Texture = THREE.ImageUtils.loadTexture( GetPanoFilename(), new THREE.UVMapping() );
				
				var material = new THREE.MeshBasicMaterial( {
														   map: Texture,
														   color: "white",
														   wireframe: false
										   } );
				LoadHigher( material );
				
	
				mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );
			
				if ( HasWebGl() )
					renderer = new THREE.WebGLRenderer();
				else
					renderer = new THREE.CanvasRenderer();
				renderer.setClearColor( 0xFF0000, 1);
		
				container.appendChild( renderer.domElement );

				if ( IsStereoView() )
				{
					effect = new THREE.StereoEffect( renderer );
					effect.separation = 1;
				}
				
				onWindowResize();

			//	window.addEventListener( 'resize', onWindowResize, false );
				animate();
			}

			function onWindowResize() {
				var Container = renderer.domElement.parentNode;
				console.log(Container);
				var w = Container.clientWidth;
				var h = Container.clientHeight;

				camera.aspect = w / h;
				camera.updateProjectionMatrix();

				if ( effect )
					effect.setSize( w, h );
				else
					renderer.setSize( w, h );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();

			}

			function render() {

				var timer = 0.0001 * Date.now();

if ( isUserInteracting === false ) {
	
	lon += 0.1;
	
}

camera.target = GetForward().add( camera.position );
camera.lookAt( camera.target );

/*
				camera.position.x += ( mouseX - camera.position.x ) * .05;
				camera.position.y += ( - mouseY - camera.position.y ) * .05;
				camera.lookAt( scene.position );
*/


				if ( effect )
					effect.render( scene, camera );
				else
					renderer.render( scene, camera );

			}
		
		function onDocumentMouseDown( event ) {
			
			event.preventDefault();
			
			isUserInteracting = true;
			
			onPointerDownPointerX = event.clientX;
			onPointerDownPointerY = event.clientY;
			
			onPointerDownLon = lon;
			onPointerDownLat = lat;
			
		}
		
		function onDocumentMouseMove( event ) {
			
			//	mouseX = ( event.clientX - windowHalfX ) * 10;
			//	mouseY = ( event.clientY - windowHalfY ) * 10;
			
			if ( isUserInteracting === true ) {
				
				lon = ( onPointerDownPointerX - event.clientX ) * 0.1 + onPointerDownLon;
				lat = ( event.clientY - onPointerDownPointerY ) * 0.1 + onPointerDownLat;
				
			}
			
		}
		
		function onDocumentMouseUp( event ) {
			
			isUserInteracting = false;
			
		}
		
		function onDocumentMouseWheel( event ) {
			
			// WebKit
			
			if ( event.wheelDeltaY ) {
				
				camera.fov -= event.wheelDeltaY * 0.05;
				
				// Opera / Explorer 9
				
			} else if ( event.wheelDelta ) {
				
				camera.fov -= event.wheelDelta * 0.05;
				
				// Firefox
				
			} else if ( event.detail ) {
				
				camera.fov += event.detail * 1.0;
				
			}
			
			camera.updateProjectionMatrix();
			
		}
		
		</script>
		
		
		<script>
		//	main
		var Info = document.getElementById("info");
		if ( Info )
		{
			/*
			Info.innerText += " | " + navigator.userAgent;
			if ( HasWebGl() )
				Info.innerText += " | has webgl";
			else
				Info.innerText += " | no webgl";
			 */
		}
		
		//	treat ipad as a device we can use with cardboard
		if ( IsDevice("iPad") )
		{
			var Container = document.getElementById("container");
			if ( Container )
				Container.className = "ipad_smallviewport";
		}
		
		//	enable uploader for ipad
		if ( EnableFileUploader() )
		{
			var Uploader = document.getElementById("uploader");
			if ( Uploader )
			{
				//Uploader.visibility = show;
				Uploader.addEventListener('change', handleFileUpload, false);
			}
		}


		var Container = document.getElementById("container");
		if ( IsSupported() )
		{
			init( Container );
		}
		else
		{
			var Container = document.getElementById("container");
			Container.style.padding = "20%";
			Container.innerText = "Not currently supported with webgl. Get the AppStore app.";
		}
		
		</script>

	</body>
</html>
