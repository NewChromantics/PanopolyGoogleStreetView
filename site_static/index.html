<!DOCTYPE html>
<html lang="en">
<head>
	<title>panopo.ly</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel="Stylesheet" href="panopoly.css" type="text/css">
	<link rel="Stylesheet" href="Cubemap.css" type="text/css">
</head>

	<body>
		<div id="info">
			panopo.ly
			<div id="Uptime" class="Button">0</div>

			<div id="ImageSelector" class="FileInput">
				Select Image
				<form id="uploaderform" enctype="multipart/form-data" method="POST">
					<input id="image_selector" name="image" type="file" />
				</form>
			</div>
			
			<div id="ImageUploader" class="FileInput">
				Upload Image<br />
				<input type="text" id="ImageUploader_CustomName" name="CustomName" class="cleardefault" value="custom url" />
				<input type="button" value="Upload File"  onclick="UploadImage()"/>
				<progress id="progressBar" value="0" max="100" style="width:300px;"></progress>
				<h3 id="status"></h3>
				<p id="loaded_n_total"></p>
			</div>
			
			<div id="ClearButton" class="Button" onClick="DestroyPano()">
				Clear
			</div>
			<div id="ShrinkButton" class="Button" onClick="SupportToggleEnable('Shrink')">
				Shrink
			</div>
			<div id="SplitButton" class="Button" onClick="ToggleSplit()">
				Stereo View
			</div>
			
			<div id="OculusBridgeButton" class="Button" onClick="SupportToggleEnable('OculusBridge')">
				OculusBridge
			</div>
			
			<div id="OculusRestButton" class="Button" onClick="SupportToggleEnable('OculusRest')">
				OculusRest
			</div>
			
			<div id="FullscreenButton" class="Button" onClick="SupportToggleEnable('Fullscreen')">
				Fullscreen
			</div>
			
			<div id="GyroButton" class="Button" onClick="SupportToggleEnable('Gyro')">
				Gyro
			</div>
			
			<div id="QuatDebug" class="Button">
				quaternion
			</div>
			
		</div>

<!-- needs to be before any support that wants to bind to container -->
		<div id="container"></div>

		<script src="js/soy.js"></script>
		<script src="threejs/three.min.js"></script>
		<script src="threejs/renderers/CSS3DRenderer.js"></script>
		<script src="threejs/effects/StereoEffect.js"></script>
		<script src="js/GoogleAnalytics.js"></script>
		<script src="js/ClearDefaultText.js"></script>
		<script src="js/SoyWebSocket-1.0.js"></script>
		<script src="js/panopoly.js"></script>
		<script src="js/CubeMap.js"></script>
		<script src="js/support.js"></script>
		<script src="js/SoySupport.js"></script>
		<script src="js/SoyOculusBridge.js"></script>
		<script src="js/SoyOculusRest.js"></script>
		<script src="js/SoyShrink.js"></script>
		<script src="js/SoyFullscreen.js"></script>
		<script src="js/SoyGyro.js"></script>
		<script src="js/SoyFileSelect.js"></script>
		<script src="js/SoyMouse.js"></script>
		<script src="js/SoyCss3d.js"></script>
		<script src="js/SoyWebgl.js"></script>
		<script src="js/SoyConfig.js"></script>
		<script src="js/SoyAsset.js"></script>
		<script src="js/SoyPano.js"></script>
	

<div id="debug_console" style="overflow:scroll;height:200px;z-index:999;position:absolute;left:0;top:20px;opacity:0.5;background:white;"></div>

<script>
	
	ShowElement('debug_console',false);
	ShowElement('ClearButton');
	ShowElement('SplitButton');
	
//	turn on debug stuff
if ( window.location.hash == '#debug' )
{
	//alert('debug mode');
	ShowElement('QuatDebug');
	
	BindConsole('debug_console');
	ShowElement('debug_console');
	
	function UpdateUptime()
	{
		ShowElement("Uptime");
		var Container = GetElement("Uptime");
		if ( !Container )
		return;
		Container.innerText = parseInt( Container.innerText ) + 1;
		setTimeout( UpdateUptime, 1000 );
	}
	UpdateUptime();
}

	
function OnOculusBridgeSupportChanged($Supported)
{
	ShowElement('OculusBridgeButton', $Supported);
	CheckAutoSwitch( 'OculusBridge', $Supported );
}

function OnOculusRestSupportChanged($Supported)
{
	ShowElement('OculusRestButton', $Supported);
	CheckAutoSwitch( 'OculusRest', $Supported );
}

function OnShrinkSupportChanged($Supported)
{
	ShowElement('ShrinkButton', $Supported);
	CheckAutoSwitch( 'Shrink', $Supported );
}

function OnFullscreenSupportChanged($Supported)
{
	ShowElement('FullscreenButton', $Supported);
	CheckAutoSwitch( 'Fullscreen', $Supported );
}

function OnGyroSupportChanged($Supported)
{
	ShowElement('GyroButton', $Supported);
	CheckAutoSwitch( 'Gyro', $Supported );
}



function OnFileSelectSupportChanged()
{
	var $Supported = IsSupported('FileSelect');
	var Uploader = GetElement("image_selector");
	if ( Uploader )
	{
		ShowElement("ImageSelector", $Supported );
		if ( $Supported )
			Uploader.addEventListener('change', OnFileSelect, false);
		else
			Uploader.removeEventListener('change', OnFileSelect, false);
	}
}


//	support callbacks
AddOnSupportedChangedListener('OculusBridge', OnOculusBridgeSupportChanged );
AddOnSupportedChangedListener('OculusRest', OnOculusRestSupportChanged );
AddOnSupportedChangedListener('Shrink', OnShrinkSupportChanged );
AddOnSupportedChangedListener('Fullscreen', OnFullscreenSupportChanged );
AddOnSupportedChangedListener('Gyro', OnGyroSupportChanged );
AddOnSupportedChangedListener('FileSelect', OnFileSelectSupportChanged );


//	scene
var camera, scene;
var mesh, lightMesh, geometry;
var spheres = [];
var directionalLight, pointLight;
var $Config = null;
var $Pano = null;
var $RendererLeft = null;
var $RendererRight = null;


function IsSplitMode()
{
	return $Config.mSplitEnabled;
}
function SetSplitMode($Enable)
{
	$Config.mSplitEnabled = $Enable;
}
function ToggleSplit()
{
	SetSplitMode( !IsSplitMode() );
}



		function OnFileUploadSupported($Enable)
		{
			//	image binary loaded okay, enable upload
			ShowElement("ImageUploader", $Enable );
		}
		
		function UploadImage()
		{
			GetElement("progressBar").value = 0;
			GetElement("status").innerHTML = "";

			var formdata = new FormData();
			var file = GetElement("image_selector").files[0];
			//alert(file.name+" | "+file.size+" | "+file.type);
			formdata.append("image", file);
			var defaultcustomname = GetElement("ImageUploader_CustomName").defaultText;
			var customname = GetElement("ImageUploader_CustomName").value;
			if ( customname != defaultcustomname )
				formdata.append("customname", customname );
			var ajax = new XMLHttpRequest();
			ajax.upload.addEventListener("progress", OnUploadProgress, false);
			ajax.addEventListener("load", OnUploadComplete, false);
			ajax.addEventListener("error", OnUploadError, false);
			ajax.addEventListener("abort", OnUploadAbort, false);
			ajax.open("POST", GetUploadUrl() );
			//ajax.setRequestHeader('Content-Type', 'multipart/form-data;');
			ajax.send(formdata);
			console.log("post'd to " + GetUploadUrl() );
		}

		function OnUploadProgress(event)
		{
			GetElement("loaded_n_total").innerHTML = "Uploaded "+event.loaded+" bytes of "+event.total;
			var percent = (event.loaded / event.total) * 100;
			GetElement("progressBar").value = Math.round(percent);
			GetElement("status").innerHTML = Math.round(percent)+"% uploaded... please wait";
		}

		function OnUploadError($Event)
		{
			var $Error = "Unknown error";
			if ( $Event.error != undefined )
				$Error = $Event.error;
			GetElement("status").innerHTML = "Upload Failed: " + $Error;
		}

		function OnUploadAbort(event)
		{
			var $Event = {};
			$Event.error = "Upload Aborted";
			OnUploadError($Event);
		}
		
		function OnUploadComplete($Event)
		{
			//	decode response
			var $Json = {};
			try
			{
				$Json = JSON.parse(event.target.responseText);
			}
			catch ( e )
			{
				$Json.error = "Error parsing response from server " + e.message;
			}
			
			console.log($Json);
			
			if ( $Json.error )
			{
				var $Event = {};
				$Event.error = $Json.error;
				OnUploadError($Event);
				return;
			}
			
			if ( $Json.panoname === undefined )
			{
				var $Event = {};
				$Event.error = "No error, but no pano name recieved";
				OnUploadError($Event);
				return;
			}
			
			var $Url = window.location + "#" + $Json.panoname;
			GetElement("status").innerHTML = 'Your new url is <a href="' + $Url + '">' + $Url + '</a>';
		}

		function OnClickedShrink()
		{
			EnableShrink( !IsShrinkEnabled() );
		}


function OnClickedRiftMode()
{
	if ( !IsRiftModeSupported() )
		return false;
		
	var OldFullscreen = IsFullscreen();
	var OldSplitMode = IsSplitMode();
	
	//	go full screen
	if ( !SetFullscreen(true) )
		return false;
	
	//	enable split mode
	if ( !SetSplitMode(true) )
	{
		SetFullscreen(OldFullscreen);
		return false;
	}
	
	//	use rift control
	if ( !CreateRiftControl() )
	{
		SetFullscreen(OldFullscreen);
		return false;
	}
	
	return true;
}





			function GetPanoName()
			{
				//	extract from url;
				//	panopo.ly/#name
				var Name = window.location.hash;
				if ( Name == '#debug' || Name == 'debug' )
					Name = null;
				if ( !Name )
					Name = "Apartment11";
				
				//	assume this might not be the case on all browsers, but chrome's .hash starts with an octothorpe
				if ( Name[0] == '#' )
					Name = Name.substr(1);
				
				return Name;
			}


			function OnFileSelect($Event)
			{
				var files = $Event.target.files; // FileList object
				
				var File = files[0];
				if ( !File )
					return;

				if ( File.type.startsWith('image') )
				{
					//	get image as datauri for texture
					var $Reader = new FileReader();
					$Reader.onload = OnLoadLocalTexture;
					$Reader.readAsDataURL(File);
				}
				else if ( File.type.startsWith('video') )
				{
					var $Reader = new FileReader();
					$Reader.onload = OnLoadLocalVideo;
					$Reader.readAsArrayBuffer(File);
				}
				else
				{
					alert("Don't know what to do with " + File.type + " file type");
				}
			}
		


function DestroyPano()
{
	//	kill old pano
	if ( $Pano )
	{
		$Pano.Destroy();
		delete $Pano;
		$Pano = null;
	}
}

function LoadPano($Config)
{
	var $PanoName = GetPanoName();
	if ( $PanoName == false )
		return false;

	var OnFailedMeta = function() { alert("Failed to load pano " + $PanoName); }

	DestroyPano();
	$Pano = new SoyPano( $PanoName, $Config, $Config.mOnNewFrame, OnFailedMeta );
}

function NewPano($Config,$Asset)
{
	DestroyPano();

	var OnFailedMeta = function() { alert("Failed to load pano " + $PanoName); }

	$Pano = new SoyPano( 'New', $Config, $Config.mOnNewFrame, OnFailedMeta, false );
	$Pano.AddAsset( $Asset );

}

	function OnLoadLocalVideo($Event)
	{
		alert("Video loading is WIP");
	}

	function OnLoadLocalTexture($Event)
	{
		var $ImageData = $Event.target.result;
		var $Image = document.createElement( 'img' );
		$Image.src = $ImageData;
		
		var OnFailed = function() { alert('failed'); };
		var OnSuccess = function($Asset)
		{
			//	asset loaded okay. Kill old Pano (stops video) and create a new one with this asset
			NewPano( $Config, $Asset );
			
			OnFileUploadSupported(true);
		};
		
		var $Meta = { 'Filename': '' };
		//console.log("creating new asset");
		var $Asset = new SoyAsset_Image( $Meta, OnSuccess, OnFailed, false );
		$Asset.mUrl = $ImageData;
		$Asset.Load();
	}


	function CreateSceneCube($Renderer,$Config,$CreateTextures)
	{
		var $CubeParent = document.createElement('div');
		var $FaceSize = $Config.mFaceResolution;
		
		//	need width & margin to center 3D around 2D center
		$CubeParent.style.width = $FaceSize + 'px';
		$CubeParent.style.height = $FaceSize + 'px';
		//	 $CubeParent.style.margin = 'auto';
		$CubeParent.className = 'ThreeD';
		
		//	% or px, no difference
		$Transform = 'translate3d(-50%,-50%,0)';
		//$Transform = 'translate3d(-' + ($FaceSize/2) + 'px,-' + ($FaceSize/2) + 'px,0)';
		$Transform += ' rotateZ(180deg)';
		SetElementTransform3d( $CubeParent, $Transform );
		
		var $RenderCameraElement = $Renderer.domElement.firstChild;
		$RenderCameraElement.appendChild($CubeParent);
		var $Cube = CreateCube( $CubeParent, $FaceSize, $CreateTextures );
		return $Cube;
	}


			function InitWebgl($Config)
			{
				var $Container = $Config.mContainer;
				var fov = $Config.mFov;
				camera = new THREE.PerspectiveCamera( fov, 1, 1, 1000 );
				camera.target = new THREE.Vector3( 0, 0, 1 );
				camera.position.set( 0.001, 0.001, 0.001 );
		
				scene = new THREE.Scene();
				


				if ( $Config.mRenderMode == RENDERMODE_CUBEMAP )
				{
					$RendererLeft = new THREE.CSS3DRenderer();
					$RendererRight = new THREE.CSS3DRenderer();
				}
				else if ( $Config.mRenderMode == RENDERMODE_WEBGL )
				{
					$RendererLeft = new THREE.WebGLRenderer();
				}
				else if ( $Config.mRenderMode == RENDERMODE_CANVAS )
				{
					$RendererLeft = new THREE.CanvasRenderer();
				}
				
				if ( !$RendererLeft )
					return false;
					
				if ( $RendererLeft )
				{
					$RendererLeft.setClearColor( 0xFF0000, 1);
					$Container.appendChild( $RendererLeft.domElement );
				}
				
				if ( $RendererRight )
				{
					$RendererRight.setClearColor( 0x00FF00, 1);
					$Container.appendChild( $RendererRight.domElement );
				}

				if ( $Config.mRenderMode != RENDERMODE_CUBEMAP )
				{
					var WidthSegments = 60;
					var HeightSegments = 40;
					if ( IsMobile() )
					{
						WidthSegments /= 2;
						HeightSegments /= 2;
					}
					var Size = $Config.mFaceResolution/2;
					var geometry = new THREE.SphereGeometry( Size, WidthSegments, HeightSegments );
					//var geometry = new THREE.BoxGeometry( Size, Size, Size );
					geometry.applyMatrix( new THREE.Matrix4().makeScale( -1, 1, 1 ) );

					//	load default texture
					var Texture = THREE.ImageUtils.loadTexture( GetDefaultPanoFilename(), new THREE.UVMapping() );
					var material = new THREE.MeshBasicMaterial( {
															   map: Texture,
															   color: "white",
															   wireframe: false
											   } );
					
		
					mesh = new THREE.Mesh( geometry, material );
					scene.add( mesh );

					//	gr: add this to render DOM features, but currently needs CSS camera
					//var $Cube = CreateSceneCube( renderer, $Config, false );
				
				}
				else
				{
					//	need to make both for switching back and forth
					var $CubeLeft = CreateSceneCube( $RendererLeft, $Config, true );
					var $CubeRight = CreateSceneCube( $RendererRight, $Config, true );
				//	var $CubeLeft = null;
				//	var $CubeRight = null;
					$Config.mRenderCubes = new Array( $CubeLeft, $CubeRight );
					$Config.mFeatureCubes = new Array( $CubeLeft, $CubeRight );
				}


				effect = new THREE.StereoEffect( $RendererLeft, $RendererRight );
				effect.separation = $Config.mFaceResolution * 0.10;
				$Config.mSplitEnabled = false;


			//	onContainerResize($Config);
				window.addEventListener( 'resize', function() { onContainerResize($Config); }, false );
				Animate($Config);
				
				return true;
			}

			function onContainerResize($Config)
			{
				var Container = $Config.mContainer;
				var w = Container.clientWidth;
				var h = Container.clientHeight;

				camera.aspect = w / h;
				camera.updateProjectionMatrix();
			
				effect.setSize( w, h );

				if ( $RendererLeft )
				{
					$RendererLeft.setSize( w, h );
					$RendererLeft.setViewport( 0, 0, w, h );
				}
				
				//	not expecting right renderer here
				if ( $RendererRight )
				{
					$RendererRight.setSize( w, h );
					$RendererRight.setViewport( 0, 0, 0, 0 );
				}
			}

			//

			function Animate($Config) {

				requestAnimationFrame( function(){Animate($Config);} );
				
				Render($Config);
			}

			function Render($Config) {

				var timer = 0.0001 * Date.now();

				//	update camera
				var Quaternion = GetCameraQuaternion();
				camera.quaternion.copy( Quaternion );
				
				var QuatDebugElement = GetElement("QuatDebug");
				if ( QuatDebugElement )
					QuatDebugElement.innerText = $CurrentCameraControl + ": " + Quaternion.x + " " + Quaternion.y + " " + Quaternion.z + " " + Quaternion.w;
				
				onContainerResize( $Config );
				
				if ( effect && $Config.mSplitEnabled )
				{
				//	effect.setSize( w, h );
					effect.render( scene, camera );
				}
				else
				{
					if ( $RendererLeft )
						$RendererLeft.render( scene, camera );
				//	if ( $RendererRight )
				//		$RendererRight.render( scene, camera );
				}
			}
	
	
		function UpdateTexture($Asset)
		{
			if ( $Config.mRenderMode == RENDERMODE_CUBEMAP )
			{
				for ( var $Key in $Config.mRenderCubes )
					SetCubemapBackground( $Asset, $Config.mRenderCubes[$Key] );
			}
			else
			{
				var $Material = mesh.material;
				
				//	already assigned to this asset, so just update it
				if ( $Material.map.image == $Asset.mAsset )
				{
					//console.log("refreshing asset");
					$Material.map.needsUpdate = true;
				}
				else
				{
					//console.log("new texture");
					var $Texture = new THREE.Texture( $Asset.mAsset, new THREE.UVMapping() );
					$Texture.generateMipmaps = false;
					$Texture.minFilter = THREE.LinearFilter;
					$Texture.magFilter = THREE.LinearFilter;
					$Texture.needsUpdate = true;
					
					$Material.map = $Texture;
					$Material.needsUpdate = true;
				}
			}
			
			return true;
		}

		//	save initial mode
		PushMode();
		
		//	init support
		AddDefaultSupportAutoSwitch();
		InitSupport();
		
		
		//	todo: load pano, if meta ONLY supports cubemap, we need cubemap mode. same with videos...
		
		//	setup config
		var $RenderMode = RENDERMODE_NONE;
		
		if ( IsCanvasSupported() && IsSupported('Webgl') )
		{
			$RenderMode = RENDERMODE_WEBGL;
		}
		else if ( IsCanvasSupported() && IsSupported('Css3d') )
		{
			$RenderMode = RENDERMODE_CUBEMAP;
		}

	$RenderMode = RENDERMODE_CUBEMAP;
						
		$Config = new SoyConfig( $RenderMode );
		$Config.mContainer = GetElement("container");
		$Config.mOnNewFrame = UpdateTexture;
	
		if ( $Config.mRenderMode != RENDERMODE_NONE )
		{
			InitWebgl( $Config );

			//	load user's required pano
			LoadPano( $Config );
		}
		else
		{
			ShutdownSupport();
			Container.style.padding = "20%";
			Container.innerText = "Not currently supported without webgl or css3d.";
			
		}


			</script>

	</body>
</html>
