<!DOCTYPE html>
<html lang="en">
<head>
	<title>panopo.ly</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel="Stylesheet" href="panopoly.css" type="text/css">
	<link rel="Stylesheet" href="Cubemap.css" type="text/css">
</head>

<script id="postfillvertshader" type="x-shader/x-vertex">
	varying vec2 vUv;
	void main()
	{
		vUv = position.xy;
		vUv += vec2(1.0,1.0);
		vUv /= vec2(2.0,2.0);
	//	vUv.y = 1.0 - vUv.y;	//	uv is upside, but so is texture (as original scene was upside down)
		
		float Scale = 1.00;
		gl_Position = vec4( position.x*Scale, position.y*Scale, 0.0, 1.0 );
	}
</script>


<script id="postfillfragshader" type="x-shader/x-frag">
	const float InfDepthValue = 0.90;
	const float InfDepthValueMin = 0.89;
	const int PixelOffsetMax = 80;
	varying vec2 vUv;
	uniform sampler2D DiffuseTexture;
	uniform int PixelOffsetCount;
	uniform vec2 PixelOffsets[PixelOffsetMax];// = { vec2(0.0,0.0) };
	uniform vec2 PixelScalar;
	
	//	w is 0 if we sampled nothing
	vec4 GetSample(vec2 Uv,vec2 Offset)
	{
		vec4 Colour = texture2D( DiffuseTexture, Uv + Offset );
		
		//Colour.w = (Colour.w >= InfDepthValue) ? 0.0 : 1.0;
	//	Colour.w = (Colour.w > InfDepthValue) ? 0.0 : 1.0;
		return Colour;
	}

	bool IsSampleDepthValid(vec4 Sample)
	{
//		return (Sample.w >= InfDepthValueMin) ? false : true;
		return (Sample.w > InfDepthValue) ? false : true;
	}

	//	yellow if have A sample, blue if not
	vec4 GetSampleTest()
	{
		vec4 Sample = vec4( 0.0, 0.0, 0.0, 0.0 );
		int SampleCount = 0;
		for ( int i=0;	i<PixelOffsetMax;	i++ )
		{
			if ( i >= PixelOffsetCount )
				continue;
				
			vec4 NewSample = GetSample( vUv, PixelOffsets[i] * PixelScalar );
			if ( !IsSampleDepthValid(NewSample) )
				continue;
			Sample += NewSample;
			SampleCount++;
		}
		
		if ( SampleCount == 0 )
		{
			return vec4( 0.0, 0.0, 1.0, 1.0 );
		}

		return vec4( 1.0, 1.0, 0.0, 1.0 );
	}
	
	void main()
	{
		//	debug test to make sure we cover all pixels
		//gl_FragColor = GetSampleTest();	return;
		
		//	if we have a good pixel, just use it
		vec4 BaseSample = GetSample( vUv, vec2(0.0,0.0) );
		/*
		if ( IsSampleDepthValid( BaseSample ) )
		{
			gl_FragColor = BaseSample;
			gl_FragColor.w = 1.0;
			return;
		}
		*/
		
		vec4 Sample = vec4( 0.0, 0.0, 0.0, 9990.0 );
		int SampleCount = 0;
		int GoodTests = 0;
		for ( int i=0;	i<PixelOffsetMax;	i++ )
		{
			if ( i >= PixelOffsetCount )
				continue;
			//	arbitry cut off to improve framerate
			if ( GoodTests + SampleCount > 5 )
				break;
				
			vec4 NewSample = GetSample( vUv, PixelOffsets[i] * PixelScalar );
			if ( !IsSampleDepthValid(NewSample) )
				continue;
			
			if ( NewSample.w < Sample.w * 0.95 )
			{
				Sample = NewSample;
				SampleCount = 1;
				GoodTests++;
				continue;
			}
			
			//	if new sample is further than current one, don't use it
			if ( NewSample.w > Sample.w * 1.00 )
				continue;
			
			Sample.xyz += NewSample.xyz;
			Sample.w = min( Sample.w, NewSample.w );
			SampleCount ++;
			GoodTests++;
			//break;
		}
		
		if ( SampleCount == 0 )
		{
			gl_FragColor = vec4( 1.0, 1.0, 0.0, 1.0 );
			BaseSample.w = 1.0;
			gl_FragColor = BaseSample;
			return;
		}
	
		//	normalise (to get average colour)
		Sample.xyz /= float(SampleCount);
		Sample.w = 1.0;
		Sample = min(Sample,1.0);
		gl_FragColor = Sample;
	}
</script>

<script id="pointcloudvertexshader" type="x-shader/x-vertex">
	
	
	varying vec4 vColor;
	uniform sampler2D DiffuseTexture;
	uniform sampler2D DepthTexture;
	uniform float gDepthNear;
	uniform float gDepthFar;
	uniform float gPointSize;
	uniform float gWorldYaw;
	const float InfDepthValue = 0.90;
	
	//	from http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
	/*
	 vec4 EncodeFloatRGBA( float v )
	 {
	 vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;
	 enc.x = frac(enc.x);
	 enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);
	 return enc;
	 }
	 */
float DecodeFloatRGBA( vec4 rgba )
{
	return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );
}

float DecodeFloatRGB( vec4 rgba )
{
	return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 0.0) );
}

//	from my php code
vec3 VectorFromCoordsRad(vec2 latlon)
{
	//	http://en.wikipedia.org/wiki/N-vector#Converting_latitude.2Flongitude_to_n-vector
	float latitude = latlon.x;
	float longitude = latlon.y;
	float las = sin(latitude);
	float lac = cos(latitude);
	float los = sin(longitude);
	float loc = cos(longitude);
	
	return vec3( los * lac, las, loc * lac );
}
#define M_PI 3.1415926535897932384626433832795

vec2 GetLatLong(float x,float y,float Width,float Height)
{
	float xmul = 2.0;
	float xsub = 1.0;
	float ymul = 1.0;
	float ysub = 0.5;
	
	float xfract = x / Width;
	xfract *= xmul;
	
	//	float yfract = (Height - y) / Height;
	float yfract = (y) / Height;
	yfract *= ymul;
	
	float lon = ( xfract - xsub) * M_PI;
	float lat = ( yfract - ysub) * M_PI;
	return vec2( lat, lon );
}

float lerp(float From,float To,float Time)
{
	return From + (To-From)*Time;
}

void main()
{
	//	debug view different angle
	float x = position.x + gWorldYaw;
	if ( x < 0.0 )
		x += 1.0;
	if ( x > 1.0 )
		x -= 1.0;
	
	vec2 Diffuseuv = vec2( 1.0-x,position.y );
	vec2 Depthuv = vec2( 1.0-x,position.y );

	vec4 Depth4 = texture2D( DepthTexture, Depthuv );
	bool DepthInf = Depth4.w < 0.5;
	Depth4.w = 0.0;
	float Depthf = DepthInf ? InfDepthValue : DecodeFloatRGB( Depth4 ) / InfDepthValue;

	///Depthf = 1.0;
	//	lat lon to view
	vec3 View3 = VectorFromCoordsRad( GetLatLong(position.x, position.y,1.0,1.0) );
	View3 = normalize(View3);

	//	gr: have a near value so the floor bends and isnt flat...
	float WorldDepth = lerp( gDepthNear, gDepthFar, Depthf );
	vec3 World3 = View3 * WorldDepth;

	vec4 World4 = modelViewMatrix * vec4( World3, 1.0 );
	
	gl_PointSize = gPointSize;
	
	gl_Position = projectionMatrix * World4;
	
	vColor = texture2D( DiffuseTexture, Diffuseuv );
	
	if ( DepthInf )
	{
		float InfColourScale = 1.0;
		//gl_PointSize = 0.0;
		vColor.r *= InfColourScale;
		vColor.g *= InfColourScale;
		vColor.b *= InfColourScale;
		
	}
	else
	{
		//vColor.r = 1.0-Depthf;
		//	vColor.g = 1.0-Depthf;
		//vColor.b = 1.0-Depthf;
	}
	
	//	fake stencil - default clear "colour" has alpha of 1.0
	//	if we write anything, alpha is zero
	//vColor.a = 0.0;
	vColor.a = Depthf;
}
</script>

	<body>
		<div id="info">
			panopo.ly
			<div id="Uptime" class="Button">0</div>

			<div id="ImageSelector" class="FileInput">
				Select Image
				<form id="uploaderform" enctype="multipart/form-data" method="POST">
					<input id="image_selector" name="image" type="file" />
				</form>
			</div>
			
			<div id="ImageUploader" class="FileInput">
				Upload Image<br />
				<input type="text" id="ImageUploader_CustomName" name="customname" class="cleardefault" value="custom url" />
				<input type="text" id="ImageUploader_Layout" name="layout" class="cleardefault" value="Layout" />
				<input type="button" value="Upload File"  onclick="UploadImage()"/>
				<progress id="progressBar" value="0" max="100" style="width:300px;"></progress>
				<h3 id="status"></h3>
				<p id="loaded_n_total"></p>
			</div>
			
			<div id="ClearButton" class="Button" onClick="forEach($Configs,function($Config){DestroyPano($Config);});">
				Clear
			</div>
			<div id="ShrinkButton" class="Button" onClick="SupportToggleEnable('Shrink')">
				Shrink
			</div>
			<div id="SplitButton" class="Button" onClick="ToggleSplit()">
				Stereo View
			</div>
			
			<div id="DebugCameraButton" class="Button" onClick="ToggleDebugCamera()">
				Debug camera
			</div>
			
			<div id="OculusBridgeButton" class="Button" onClick="SupportToggleEnable('OculusBridge')">
				OculusBridge
			</div>
			
			<div id="OculusRestButton" class="Button" onClick="SupportToggleEnable('OculusRest')">
				OculusRest
			</div>
			
			<div id="FullscreenButton" class="Button" onClick="SupportToggleEnable('Fullscreen')">
				Fullscreen
			</div>
			
			<div id="GyroButton" class="Button" onClick="SupportToggleEnable('Gyro')">
				Gyro
			</div>
			
			<div id="QuatDebug" class="Button">
				quaternion
			</div>
			
			<div id="PosDebug" class="Button">
				position
			</div>
			
		</div>

<!-- needs to be before any support that wants to bind to container -->
<div class="Container" id="container"></div>
<div class="Container" id="container_dual"></div>


		<script src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false" type="text/javascript"></script>
		<script src="js/soy.js"></script>
		<script src="js/zpipe.min.js"></script>
		<script src="threejs/three.min.js"></script>

		<script src="threejs/renderers/CSS3DRenderer.js"></script>
		<script src="threejs/effects/StereoEffect.js"></script>
		<script src="threejs/controls/OrbitControls.js"></script>


<!--
 <script src="threejs/Three.js"></script>
 <script src="threejs/math/Quaternion.js"></script>
 <script src="threejs/math/Math.js"></script>
 <script src="threejs/math/Vector2.js"></script>
 <script src="threejs/math/Vector3.js"></script>
 <script src="threejs/math/Vector4.js"></script>
 <script src="threejs/math/Matrix3.js"></script>
 <script src="threejs/math/Matrix4.js"></script>
 <script src="threejs/math/Euler.js"></script>
 <script src="threejs/math/Color.js"></script>
 <script src="threejs/math/Plane.js"></script>
 <script src="threejs/math/Line3.js"></script>
 <script src="threejs/math/Box3.js"></script>
 <script src="threejs/math/Sphere.js"></script>
 <script src="threejs/math/Frustum.js"></script>
 <script src="threejs/math/Ray.js"></script>
 <script src="threejs/core/EventDispatcher.js"></script>
 <script src="threejs/core/Projector.js"></script>
 <script src="threejs/core/Object3D.js"></script>
 <script src="threejs/core/Geometry.js"></script>
 <script src="threejs/core/Face3.js"></script>
 <script src="threejs/objects/Mesh.js"></script>
 <script src="threejs/objects/Bone.js"></script>
 <script src="threejs/objects/SkinnedMesh.js"></script>
 <script src="threejs/lights/Light.js"></script>
 <script src="threejs/cameras/Camera.js"></script>
 <script src="threejs/cameras/PerspectiveCamera.js"></script>
 <script src="threejs/scenes/Scene.js"></script>
 <script src="threejs/textures/Texture.js"></script>
 <script src="threejs/materials/Material.js"></script>
 <script src="threejs/materials/ShaderMaterial.js"></script>
 <script src="threejs/materials/MeshBasicMaterial.js"></script>
 <script src="threejs/renderers/shaders/ShaderChunk.js"></script>
 <script src="threejs/renderers/shaders/UniformsLib.js"></script>
 <script src="threejs/renderers/shaders/UniformsUtils.js"></script>
 <script src="threejs/renderers/shaders/ShaderLib.js"></script>
 <script src="threejs/loaders/Cache.js"></script>
 <script src="threejs/loaders/LoadingManager.js"></script>
 <script src="threejs/loaders/ImageLoader.js"></script>
 <script src="threejs/extras/ImageUtils.js"></script>
 <script src="threejs/extras/geometries/SphereGeometry.js"></script>
 <script src="threejs/extras/shaders/ShaderFlares.js"></script>
 <script src="threejs/extras/renderers/plugins/ShadowMapPlugin.js"></script>
 <script src="threejs/extras/renderers/plugins/LensFlarePlugin.js"></script>
 <script src="threejs/extras/renderers/plugins/SpritePlugin.js"></script>
 <script src="threejs/extras/renderers/plugins/ShadowMapPlugin.js"></script>
 -->
		<script src="js/GoogleAnalytics.js"></script>
		<script src="js/ClearDefaultText.js"></script>
		<script src="js/SoyWebsocket-1.0.js"></script>
		<script src="js/mjpeg.js"></script>
		<script src="js/SoyRect.js"></script>
		
		<script src="js/panopoly.js"></script>
		<script src="js/CubeMap.js"></script>
		<script src="js/support.js"></script>
		<script src="js/SoySupport.js"></script>
		<script src="js/SoyOculusBridge.js"></script>
		<script src="js/SoyOculusRest.js"></script>
		<script src="js/SoyShrink.js"></script>
		<script src="js/SoyFullscreen.js"></script>
		<script src="js/SoyGyro.js"></script>
		<script src="js/SoyFileSelect.js"></script>
		<script src="js/SoyMouse.js"></script>
		<script src="js/SoyCss3d.js"></script>
		<script src="js/SoyWebgl.js"></script>
		<script src="js/SoyConfig.js"></script>
		<script src="js/SoyAsset.js"></script>
		<script src="js/SoyAsset_GsvDepth.js"></script>
		<script src="js/SoyAsset_GsvImage.js"></script>
		<script src="js/SoyAsset_GsvPanoMeta.js"></script>
		<script src="js/SoyAsset_GsvPointCloud.js"></script>
		<script src="js/SoyPano.js"></script>
	
		<script src="js/PanoMenu.js"></script>
	

<div id="debug_console" style="overflow:scroll;height:200px;z-index:999;position:absolute;left:0;top:20px;opacity:0.5;background:white;"></div>

<script>
	
WebGLChainRenderer.prototype = new THREE.WebGLRenderer();
function WebGLChainRenderer()
{
	THREE.WebGLRenderer.apply( this, arguments );
	
	this.super = {};
	this.super.render = this.render;
	
	var $w = 1024;
	var $h = 1024;
	var $options = { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, };
	this.mRenderTarget = new THREE.WebGLRenderTarget( $w, $h, $options );

	this.mPostMesh = CreatePostMesh( this.mRenderTarget );
	this.mPostCamera = new THREE.OrthographicCamera( 0, 1, 1, 0, 0, 1 );
	this.mPostScene = new THREE.Scene();
	this.mPostScene.add( this.mPostMesh );
	console.log( this.mPostMesh );
	
	this.render = this.chainrender;
}

var gPixelOffsetCount = false;

WebGLChainRenderer.prototype.chainrender = function($Scene,$Camera)
{
	this.super.render.call( this, $Scene, $Camera, this.mRenderTarget, true );

	if ( gPixelOffsetCount === false )
	{
		gPixelOffsetCount = this.mPostMesh.material.uniforms.PixelOffsetCount.value;
	}
	this.mPostMesh.material.uniforms.PixelOffsetCount.value = gPixelOffsetCount;
	this.mPostMesh.material.uniforms.PixelOffsetCount.needsUpdate = true;
	
	//	render post-process shaders
	this.super.render.call( this, this.mPostScene, this.mPostCamera );
}

function AppendCoords($Coords,$Rad,$Step)
{
	$Step = CheckDefaultParam( $Step, 1 );
	
	for ( var $x=-$Rad;	$x<=$Rad;	$x+=$Step )
	{
		var $y = -$Rad;	//	first row
		$Coords.push( new THREE.Vector2( $x, $y ) );
		var $y = $Rad;	//	last row
		$Coords.push( new THREE.Vector2( $x, $y ) );
	}

	for ( var $y=-$Rad+1;	$y<=$Rad-1;	$y+=$Step )
	{
		var $x = -$Rad;	//	first col
		$Coords.push( new THREE.Vector2( $x, $y ) );
		var $x = $Rad;	//	last col
		$Coords.push( new THREE.Vector2( $x, $y ) );
	}
}

function CreatePostMesh($RenderTargetTexture)
{
	//	create triangles
	//	gr: 2x2 generates -1 to 1
	var geometry = new THREE.PlaneGeometry( 2, 2 );

	var $VertShader = GetElement('postfillvertshader').innerText;
	var $FragShader = GetElement('postfillfragshader').innerText;
	
	var $PixelStep = new THREE.Vector2( 1.0 / $RenderTargetTexture.width, 1.0 / $RenderTargetTexture.height );
	var $PixelOffsets = [ new THREE.Vector2(0,0) ];
	
	AppendCoords( $PixelOffsets, 1, 1 );
	AppendCoords( $PixelOffsets, 3, 1 );
	AppendCoords( $PixelOffsets, 6, 3 );
	AppendCoords( $PixelOffsets, 10, 3 );
	/*
	AppendCoords( $PixelOffsets, 2, 1 );
	AppendCoords( $PixelOffsets, 6, 3 );
	AppendCoords( $PixelOffsets, 9, 3 );
	AppendCoords( $PixelOffsets, 15, 5 );
	*/
	console.log($PixelOffsets);
	//alert($PixelOffsets.length);
	
	var uniforms =
	{
		DiffuseTexture: { type: "t", value: $RenderTargetTexture },
		PixelOffsetCount: { type: "i", value: $PixelOffsets.length },
		PixelOffsets: { type: "v2v", value: $PixelOffsets },
		PixelScalar: { type: "v2", value: $PixelStep },
	};
	
	var material = new THREE.ShaderMaterial( {
											uniforms: 		uniforms,
											vertexShader:	$VertShader,
											fragmentShader: $FragShader,
											});
/*
	var material = new THREE.MeshBasicMaterial({
												color: 'red'
												});
*/	material.depthTest = false;
	material.side = THREE.DoubleSide;
	
	
	var mesh = new THREE.Mesh( geometry, material );
	return mesh;
}

</script>

<script>
	
	ShowElement('debug_console',false);
	ShowElement('SplitButton');

	ShowElement('DebugCameraButton');
	
	
//	turn on debug stuff
if ( HasHashParam('debug') )
{
	//alert('debug mode');
	ShowElement('QuatDebug');
	ShowElement('PosDebug');
	
	BindConsole('debug_console');
	ShowElement('debug_console');

	ShowElement('ClearButton');
	
	function UpdateUptime()
	{
		ShowElement("Uptime");
		var Container = GetElement("Uptime");
		if ( !Container )
			return;
		Container.innerText = parseInt( Container.innerText ) + 1;
		setTimeout( UpdateUptime, 1000 );
	}
	UpdateUptime();
}

function Debug_SetStyleBorder($Element,$Size)
{
	if ( !$Element )
		return;
	$Size = CheckDefaultParam($Size,30);
	$Element.style.left = $Size + 'px';
	$Element.style.top = $Size + 'px';
	$Element.style.bottom = $Size + 'px';
	$Element.style.right = $Size + 'px';
	console.log("updated border",$Element);
}
	
function OnOculusBridgeSupportChanged($Supported)
{
	ShowElement('OculusBridgeButton', $Supported);
	CheckAutoSwitch( 'OculusBridge', $Supported );
}

function OnOculusRestSupportChanged($Supported)
{
	ShowElement('OculusRestButton', $Supported);
	CheckAutoSwitch( 'OculusRest', $Supported );
}

function OnShrinkSupportChanged($Supported)
{
	ShowElement('ShrinkButton', $Supported);
	CheckAutoSwitch( 'Shrink', $Supported );
}

function OnFullscreenSupportChanged($Supported)
{
	ShowElement('FullscreenButton', $Supported);
	CheckAutoSwitch( 'Fullscreen', $Supported );
}

function OnGyroSupportChanged($Supported)
{
	ShowElement('GyroButton', $Supported);
	CheckAutoSwitch( 'Gyro', $Supported );
}



function OnFileSelectSupportChanged()
{
	var $Supported = IsSupported('FileSelect');
	var Uploader = GetElement("image_selector");
	if ( Uploader )
	{
		ShowElement("ImageSelector", $Supported );
		if ( $Supported )
			Uploader.addEventListener('change', OnFileSelect, false);
		else
			Uploader.removeEventListener('change', OnFileSelect, false);
	}
}


//	support callbacks
AddOnSupportedChangedListener('OculusBridge', OnOculusBridgeSupportChanged );
AddOnSupportedChangedListener('OculusRest', OnOculusRestSupportChanged );
AddOnSupportedChangedListener('Shrink', OnShrinkSupportChanged );
AddOnSupportedChangedListener('Fullscreen', OnFullscreenSupportChanged );
AddOnSupportedChangedListener('Gyro', OnGyroSupportChanged );
AddOnSupportedChangedListener('FileSelect', OnFileSelectSupportChanged );


//	scene
var $Configs = [];


function IsSplitMode()
{
	return $Configs[0].IsSplitEnabled();
}
function SetSplitMode($Enable)
{
	forEach( $Configs, function($Config)
			{
				$Config.mSplitEnabled = $Enable;
				onContainerResize($Config);
			}
			);
}
function ToggleSplit()
{
	SetSplitMode( !IsSplitMode() );
}


function IsDebugCameraMode()
{
	return $Configs[0].mEnableDebugCamera;
}
function SetDebugCameraMode($Enable)
{
	forEach( $Configs, function($Config)
			{
			$Config.mEnableDebugCamera = $Enable;
			onContainerResize($Config);
			}
			);
}
function ToggleDebugCamera()
{
	SetDebugCameraMode( !IsDebugCameraMode() );
}

		function OnFileUploadSupported($Enable)
		{
			//	image binary loaded okay, enable upload
			ShowElement("ImageUploader", $Enable );
		}

		function AppendToForm($Form,$ElementName)
		{
			var $Element = GetElement( $ElementName );
			if ( !$Element )
			return;
			
			var $FormName = $Element.name;
			var $Default = CheckDefaultParam( $Element.defaultText, '' );
			console.log('default: ',$Default,$Element);
			var $Value = $Element.value;
			if ( $Value == $Default )
			return;
			
			$Form.append( $FormName, $Value );
		}

		function UploadImage()
		{
			GetElement("progressBar").value = 0;
			GetElement("status").innerHTML = "";

			var formdata = new FormData();
			var file = GetElement("image_selector").files[0];
			//alert(file.name+" | "+file.size+" | "+file.type);
			formdata.append("image", file);
			
			AppendToForm(formdata,'ImageUploader_CustomName');
			AppendToForm(formdata,'ImageUploader_Layout');

			var ajax = new XMLHttpRequest();
			ajax.upload.addEventListener("progress", OnUploadProgress, false);
			ajax.addEventListener("load", OnUploadComplete, false);
			ajax.addEventListener("error", OnUploadError, false);
			ajax.addEventListener("abort", OnUploadAbort, false);
			ajax.open("POST", GetUploadUrl() );
			//ajax.setRequestHeader('Content-Type', 'multipart/form-data;');
			ajax.send(formdata);
			console.log("post'd to " + GetUploadUrl() );
		}

		function OnUploadProgress(event)
		{
			GetElement("loaded_n_total").innerHTML = "Uploaded "+event.loaded+" bytes of "+event.total;
			var percent = (event.loaded / event.total) * 100;
			GetElement("progressBar").value = Math.round(percent);
			GetElement("status").innerHTML = Math.round(percent)+"% uploaded... please wait";
		}

		function OnUploadError($Event)
		{
			var $Error = "Unknown error";
			if ( $Event.error != undefined )
				$Error = $Event.error;
			GetElement("status").innerHTML = "Upload Failed: " + $Error;
		}

		function OnUploadAbort(event)
		{
			var $Event = {};
			$Event.error = "Upload Aborted";
			OnUploadError($Event);
		}
		
		function OnUploadComplete($Event)
		{
			//	decode response
			var $Json = {};
			try
			{
				$Json = JSON.parse(event.target.responseText);
			}
			catch ( e )
			{
				$Json.error = "Error parsing response from server " + e.message;
			}
			
			console.log($Json);
			
			if ( $Json.error )
			{
				var $Event = {};
				$Event.error = $Json.error;
				OnUploadError($Event);
				return;
			}
			
			if ( $Json.panoname === undefined )
			{
				var $Event = {};
				$Event.error = "No error, but no pano name recieved";
				OnUploadError($Event);
				return;
			}
			
			var $Url = window.location + "#" + $Json.panoname;
			GetElement("status").innerHTML = 'Your new url is <a href="' + $Url + '">' + $Url + '</a>';
		}

		function OnClickedShrink()
		{
			EnableShrink( !IsShrinkEnabled() );
		}


function OnClickedRiftMode()
{
	if ( !IsRiftModeSupported() )
		return false;
		
	var OldFullscreen = IsFullscreen();
	var OldSplitMode = IsSplitMode();
	
	//	go full screen
	if ( !SetFullscreen(true) )
		return false;
	
	//	enable split mode
	if ( !SetSplitMode(true) )
	{
		SetFullscreen(OldFullscreen);
		return false;
	}
	
	//	use rift control
	if ( !CreateRiftControl() )
	{
		SetFullscreen(OldFullscreen);
		return false;
	}
	
	return true;
}





			function GetPanoName()
			{
				//	extract from url;
				//	panopo.ly/#name
				var Name = GetHashParam(0);
				if ( !Name )
					Name = "Apartment11";

				var $LatLon = MatchLatLonString( window.location.hash, '#' );
				if ( $LatLon !== false )
					return $GoogleStreetViewPrefix + $LatLon[0] + ',' + $LatLon[1];
					
				return Name;
			}


			function OnFileSelect($Event)
			{
				var files = $Event.target.files; // FileList object
				
				var File = files[0];
				if ( !File )
					return;

				if ( File.type.startsWith('image') )
				{
					//	get image as datauri for texture
					var $Reader = new FileReader();
					$Reader.onload = OnLoadLocalTexture;
					$Reader.readAsDataURL(File);
				}
				else if ( File.type.startsWith('video') )
				{
					var $Reader = new FileReader();
					$Reader.onload = OnLoadLocalVideo;
					$Reader.readAsArrayBuffer(File);
				}
				else
				{
					alert("Don't know what to do with " + File.type + " file type");
				}
			}
		


function DestroyPano($Config)
{
	//	kill old pano
	if ( $Config.mPano )
	{
		$Config.mPano.Destroy();
		delete $Config.mPano;
		$Config.mPano = null;
	}
}

function LoadDataPano($Config)
{
	var $ImageData = 'data:image/gif;base64,R0lGODlhyAAiALMAAFONvX2pzbPN4p6/2tTi7mibxYiw0d/q86nG3r7U5l2UwZO31unx98nb6nOiyf///yH5BAUUAA8ALAAAAADIACIAAAT/8MlJq7046827/2AojmRpnmiqriwGvG/Qjklg28es73wHxz0P4gcgBI9IHVGWzAx/xqZ0KlpSLU9Y9MrtVqzeBwFBJjPCaC44zW4HD4TzZI0h2OUjON7EsMd1fXcrfnsfgYUSeoYLPwoLZ3QTDAgORAoGWxQHNzYSBAY/BQ0XNZw5mgMBRACOpxSpnLE3qKqWC64hk5WNmBebnA8MjC8KFAygMAUCErA2CZoKq6wHkQ8C0dIxhQRED8OrC1hEmQ+12QADFebnABTr0ukh1+wB20QMu0ASCdn16wgTDmCTNlDfhG/sFODi9iMLvAoOi6hj92LZhHfZ3FEEYNEDwnMK/ykwhDEATAN2C/5d3PiDiYSIrALkg6EAz0hiFDNFJKeqgIEyM1nhwShNo0+glhBhgKlA5qqaE25KY1KAYkGAYlYVSEAgQdU1DFbFe3DgKwysWcHZ+QjAAIWdFQaMgkjk2b4ySLtNkCvuh90NYYmMLUsErVRiC8o8OLmkAYF5hZkRKYCHgVmDAiJJLeZpVUdrq/DA7XB5rAV+gkn/MJ0hc8sKm6OuclDoo8tgBQFgffd335p3cykEjSK1gIXLEl+Oq9OgTIKZtymg/hHuAoHmZJ6/5gDcwvDOyysEDS7B9VkJoSsEhuEyN6KSPyxKrf4qsnIoFQ4syL0qum8i9AW0H/9F/l3gngXwwSAfEQ5csIoFUmH1oAVrTEhXQ+Cdd6GGD4z230b+TQdDgB8S6INeG76AlVSsoYeibBg+cOAX2z1g4Vv2sYggER15uFliZFwWnUAAQmhLGUKe+MMFEa1oH40/FMKYht1RMKVB7+AiwTvEMehdeB2CicwLlAlXI1m5kSjBmACUOQF0HWRpAZcZqngBbxWwqZtkZz4QlEsJvkDiejDIcRh5h4kG5pPBrEHkDw06GKMEhAJwGxx+uBIoAIOmlxaH9TWCh4h2fgqDAWcc019AqwTHwDtu1UmMRQnkdpuHRU6gZ3uWOOaHILmuScc6LlFDhKuwwgiqsjQNgAD/UWgFZaKuq/w0AHIAuHIYReR5+A4C12HkEksSfRvuqiuxR4GebSFw7SraMqoRuXvK2t+Z+JDb22bsxDqBh+YRVCO5RgT81JnEGiNtNvvKKwl/IzJKql8ORadqQuSZis7CANCWYnIScOyAiJHayFIUIpM8r0GUstsrbA4HhC2nJi9LwDuihKkuhEQpgAAiEQpjyc99aWHMppz2gSLBlCL9iFQrW2pdz0TDPCkGCRgQjU9GVPpZQAkgIICWHfQhABkNkM1svQxg9wcJfWSn1AlxI5DA3COYjbbaLJBKzhQRuiF4Cn8nMiMXgQ+uOAkBFDDA2wxABkPJiMe8+OUaECVNLMZUJI755xtoHmwXnoNuugUQp4bGLzf0dvrriy2wsAMD4A377YJjSgDfD0QAADs=';

	//	create new pano meta which does everything for us...
	var $AssetMeta = {};
	$AssetMeta.Layout = 'cubemap_61LFRBTD';
	$AssetMeta.Filename = $ImageData;
	$AssetMeta.Format = 'jpg';	//	hmmm
	
	var $AssetMeta2 = {};
	$AssetMeta2.Layout = 'equirect';
	$AssetMeta2.Filename = $ImageData;
	$AssetMeta2.Format = 'jpg';	//	hmmm
	
	var $Meta = {};
	$Meta.isVideo = false;
	$Meta.assets = new Array( $AssetMeta, $AssetMeta2 );
	
	/*
	for ( var $Key in $Configs )
	{
		var $Config = $Configs[$Key];
		NewPano( $Config, $Meta );
	}
*/
	NewPano( $Config, $Meta );
}


function OnGoogleStreetViewFailed()
{
	alert('OnGoogleStreetViewFailed');
}


function LoadGoogleStreetViewDepth($Json)
{
	if ( IsUndefined($Json.model.depth_map ) )
		return false;
	
	//	decode depth map
	var rawDepthMap = $Json.model.depth_map;
	
	// Append '=' in order to make the length of the array a multiple of 4
	while(rawDepthMap.length %4 != 0)
		rawDepthMap += '=';
	
	// Replace '-' by '+' and '_' by '/'
	rawDepthMap = rawDepthMap.replace(/-/g,'+');
	rawDepthMap = rawDepthMap.replace(/_/g,'/');
	
	// Decode and decompress data
	var compressedDepthMapData = atob(rawDepthMap);
	var decompressedDepthMap = zpipe.inflate(compressedDepthMapData);
	
	// Convert output of decompressor to Uint8Array
	depthMap = new Uint8Array(decompressedDepthMap.length);
	for(i=0; i<decompressedDepthMap.length; ++i)
		depthMap[i] = decompressedDepthMap.charCodeAt(i);

	depthMapData = new DataView(depthMap.buffer);
	var DepthMap = new GoogleStreetViewDepthMap( depthMapData );
	if ( !DepthMap.mDepthMap )
		return false;
	
	//	turn into image
	var $DepthMapFloat = DepthMap.mDepthMap;
	console.log(DepthMap);
	var canvas = document.createElement("canvas");
	var $w = $DepthMapFloat.width;
	var $h = $DepthMapFloat.height;
	var $maxf = $DepthMapFloat.maxt;
	var $avgf = $DepthMapFloat.avgt;
	canvas.width = $w;
	canvas.height = $h;

	console.log("Generating depth image " + $w + "x" + $h );
	var ctx = canvas.getContext("2d");
	var PixelImage = ctx.createImageData(1,1); // only do this once per page
	var Pixel = PixelImage.data;                        // only do this once per page

	for ( var y=0;	y<$h;	y++ )
	for ( var x=0;	x<$w;	x++ )
	{
		var $i = (y*$w) + x;
		var $f = $DepthMapFloat.depthMap[$i];

		if ( $f > $maxf )
		{
			Pixel[0] = 0;
			Pixel[1] = 0;
			Pixel[2] = 0;
		}
		else
		{
			var $threshold = $avgf*4;
			var $far = $maxf * 0.5;
			if ( $f > $far )
				$f = $far;
			//$avgf = 10;
			if ( $f > $threshold )
			{
				$f = GetLerp( $threshold, $far, $f );
				Pixel[0] = Lerp( 0, 255, $f );
				Pixel[1] = Lerp( 255, 0, $f );
				Pixel[2] = Lerp( 0, 255, $f );
			}
			else
			{
				$f = GetLerp( 0, $threshold, $f );
				Pixel[0] = Lerp( 255, 0, $f );
				Pixel[1] = Lerp( 0, 255, $f );
				Pixel[2] = Lerp( 0, 0, $f );
			}
		}

		Pixel[3] = 255;
		ctx.putImageData( PixelImage, x, y );
	}
	
	var $DataUrl = canvas.toDataURL();
	var Image = document.createElement("img"); // create img tag
	Image.src = $DataUrl;

	return Image;
}
		
		



function LoadGoogleStreetViewPano($Config,$LatLon)
{
	var $Meta = {};
	$Meta.isVideo = false;
	$Meta.assets = new Array();

	var $AssetMeta = {};
	if ( HasHashParam('depth') )
	{
		//	load depth
		$AssetMeta.Layout = 'equirect';
		$AssetMeta.Filename = $LatLon;
		$AssetMeta.Format = 'GsvDepth';
		
	}
	else if ( HasHashParam('pointcloud') )
	{
		//	load point cloud
		//$AssetMeta.Layout = 'equirect';
		$AssetMeta.Filename = $LatLon;
		$AssetMeta.Format = 'GsvPointCloud';
	}
	else
	{
		//	load image
		$AssetMeta.Layout = 'equirect';
		$AssetMeta.Filename = $LatLon;
		$AssetMeta.Format = 'GsvImage';
	}

	$Meta.assets.push($AssetMeta);
	NewPano( $Config, $Meta );
						
	return true;
}


function LoadPano($Config)
{
//	alert('loading pano ' + $PanoName );
	var $PanoName = GetPanoName();
	if ( $PanoName == false )
		return false;
		
	if ( $PanoName.startsWith($GoogleStreetViewPrefix) )
	{
		return LoadGoogleStreetViewPano($Config,$PanoName.substr($GoogleStreetViewPrefix.length));
	}
		
	if ( $PanoName == 'data' )
		return LoadDataPano($Config);

	var OnFailedMeta = function() { alert("Failed to load pano " + $PanoName); }

	DestroyPano($Config);
	$Config.mPano = new SoyPano( $PanoName, $Config, $Config.mOnNewFrame, OnFailedMeta );
	return true;
}

function NewPano($Config,$MetaAsset)
{
	DestroyPano($Config);

	var OnFailedMeta = function() { alert("Failed to load pano " + $PanoName); }

	$Config.mPano = new SoyPano( 'New', $Config, $Config.mOnNewFrame, OnFailedMeta, false );
	$Config.mPano.mMeta = $MetaAsset;
	//console.log($MetaAsset);
	$Config.mPano.OnLoadedMeta();

	if ( $Config.mOnNewOtherAsset )
		$Config.mPano.mOnNewOtherAsset = $Config.mOnNewOtherAsset;
}

	function OnLoadLocalVideo($Event)
	{
		alert("Video loading is WIP");
	}

	function OnLoadLocalTexture($Event)
	{
		alert('OnLoadLocalTexture');
		var $ImageData = $Event.target.result;
		
		//	create new pano meta which does everything for us...
		var $AssetMeta = {};
		$AssetMeta.Layout = 'cubemap_61LFRBTD';
		$AssetMeta.Filename = $ImageData;
		$AssetMeta.Format = 'jpg';	//	hmmm
		
		var $AssetMeta2 = {};
		$AssetMeta2.Layout = 'equirect';
		$AssetMeta2.Filename = $ImageData;
		$AssetMeta2.Format = 'jpg';	//	hmmm
		
		var $Meta = {};
		$Meta.isVideo = false;
		$Meta.assets = new Array( $AssetMeta, $AssetMeta2 );

		for ( var $Key in $Configs )
		{
			var $Config = $Configs[$Key];
			NewPano( $Config, $Meta );
		}

/*	gr: consider using below to verify it's a usable image, rather than a blank display
	
			var $Meta = new SoyAssetMeta( { 'Filename': '', 'Layout': $Layout } );
			console.log("creating new asset",$Meta);
			var $Asset = new SoyAsset_Image( $Meta, function($Asset){ $OnSuccess($Asset,$Asset.mConfig);}, function($Asset){ $OnFailed($Asset,$Asset.mConfig);}, false );
			$Asset.mConfig = $Config;
			$Asset.mUrl = $ImageData;
			$Asset.Load();
 */
	}


	function CreateSceneCube($Renderer,$Config,$CreateTextures)
	{
		var $CubeParent = document.createElement('div');
		var $FaceSize = $Config.mFaceResolution;
		
		//	need width & margin to center 3D around 2D center
		$CubeParent.style.width = $FaceSize + 'px';
		$CubeParent.style.height = $FaceSize + 'px';
		//	 $CubeParent.style.margin = 'auto';
		$CubeParent.className = 'ThreeD';
		
		//	% or px, no difference
		$Transform = 'translate3d(-50%,-50%,0)';
		//$Transform = 'translate3d(-' + ($FaceSize/2) + 'px,-' + ($FaceSize/2) + 'px,0)';
		$Transform += ' rotateZ(180deg)';
		SetElementTransform( $CubeParent, $Transform );
		
		var $RenderCameraElement = $Renderer.domElement.firstChild;
		$RenderCameraElement.appendChild($CubeParent);
		var $Cube = CreateCube( $CubeParent, $FaceSize, $CreateTextures );
		return $Cube;
	}


			function InitWebgl($Config)
			{
				var $Container = $Config.mContainer;
				var fov = $Config.mFov;
				//	far Z matches furthest point on a cubemap...
				var $Far = Math.sqrt( $Config.mFaceResolution*$Config.mFaceResolution + $Config.mFaceResolution*$Config.mFaceResolution );
			
				$Config.mCamera = new THREE.PerspectiveCamera( fov, 1, 1, $Far );
			//	$Config.mCamera.target = new THREE.Vector3( 0, 0, 1 );
			//	$Config.mCamera.position.set( 0.001, 0.001, 0.001 );
			
			
				$Config.mEnableDebugCamera = HasHashParam('debugcam');
				$Config.mDebugCamera = new THREE.PerspectiveCamera( 45, 1, 1, 10000 );
				var $CameraScale = 5.0;
				$Config.mDebugCamera.position.z = $CameraScale * 3.0;
				$Config.mDebugCamera.position.y = $CameraScale * 4.0;
				$Config.mDebugCamera.lookAt(new THREE.Vector3(0,0,0));
				
				//$Config.mDebugCameraControls = new THREE.OrbitControls( $Config.mDebugCamera, $Container );
				$Config.mDebugCameraControls = new THREE.OrbitControls( $Config.mDebugCamera, document.body );
				$Config.mDebugCameraControls.scale = 0.001;
				$Config.mDebugCameraControls.target = new THREE.Vector3(0,0,0);
//				$Config.mDebugCameraControls.addEventListener( 'change', animate );

				$Config.mScene = new THREE.Scene();
				


				if ( $Config.mRenderMode == RENDERMODE_CSS )
				{
					$Config.mRendererLeft = new THREE.CSS3DRenderer();
					$Config.mRendererRight = new THREE.CSS3DRenderer();
				}
				else if ( $Config.mRenderMode == RENDERMODE_WEBGL )
				{
					$Config.mRendererLeft = new WebGLChainRenderer();
				}
				else if ( $Config.mRenderMode == RENDERMODE_CANVAS )
				{
					$Config.mRendererLeft = new THREE.CanvasRenderer();
				}
				
				if ( !$Config.mRendererLeft )
					return false;
					
				if ( $Config.mRendererLeft )
				{
					$Config.mRendererLeft.setClearColor( 0xFF0000, 1);
					$Container.appendChild( $Config.mRendererLeft.domElement );
				}
				
				if ( $Config.mRendererRight )
				{
					$Config.mRendererRight.setClearColor( 0x00FF00, 1);
					$Container.appendChild( $Config.mRendererRight.domElement );
				}


				if ( $Config.mRenderMode != RENDERMODE_CSS )
				{
					var WidthSegments = 60;
					var HeightSegments = 40;
					if ( IsMobile() )
					{
						WidthSegments /= 2;
						HeightSegments /= 2;
					}
					var Size = $Config.mFaceResolution/2;
					var geometry = new THREE.SphereGeometry( Size, WidthSegments, HeightSegments );
					//var geometry = new THREE.BoxGeometry( Size, Size, Size );
					var mtx = new THREE.Matrix4().makeScale( -1, 1, 1 );
					var rotMtx = new THREE.Matrix4().makeRotationY( Math.DegreesToRadians(-90) );
					mtx.multiply( rotMtx );
					geometry.applyMatrix( mtx );

					//	load default texture
					var Texture = THREE.ImageUtils.loadTexture( GetDefaultPanoFilename(), new THREE.UVMapping() );
					var material = new THREE.MeshBasicMaterial( {
															   map: Texture,
															   color: "white",
															   wireframe: false
											   } );
					
		
					$Config.mMesh = new THREE.Mesh( geometry, material );
					$Config.mScene.add( $Config.mMesh );

					//	gr: add this to render DOM features, but currently needs CSS camera
					//var $Cube = CreateSceneCube( renderer, $Config, false );
				
				}
				else
				{
					//	need to make both for switching back and forth
					var $CubeLeft = CreateSceneCube( $Config.mRendererLeft, $Config, true );
					var $CubeRight = CreateSceneCube( $Config.mRendererRight, $Config, true );
				//	var $CubeLeft = null;
				//	var $CubeRight = null;
					$Config.mRenderCubes = new Array( $CubeLeft, $CubeRight );
					$Config.mFeatureCubes = new Array( $CubeLeft, $CubeRight );
				}

				var $EyeScale = HasHashParam('pointcloud') ? 200.0 : 1.0;

				$Config.mSplitter = new THREE.StereoEffect( $Config.mRendererLeft, $Config.mRendererRight );
				$Config.mSplitter.separation = (1.0/$EyeScale) * $Config.mFaceResolution * $Config.mSeperation;
				//alert('seperation: ' + $Config.mSplitter.separation + ' cam far: ' + $Config.mCamera.far);
				onContainerResize($Config);
				window.addEventListener( 'resize', function() { onContainerResize($Config); }, false );
				Animate($Config);


				return true;
			}

			function onContainerResize($Config)
			{
				var Container = $Config.mContainer;
				var w = Container.clientWidth;
				var h = Container.clientHeight;

				$Config.mCamera.aspect = w / h;
				$Config.mCamera.updateProjectionMatrix();

				$Config.mDebugCamera.aspect = w / h;
				$Config.mDebugCamera.updateProjectionMatrix();

				if ( $Config.IsSplitEnabled() )
				{
					$Config.mSplitter.setSize( w, h );
				}
				else
				{
					if ( $Config.mRendererLeft )
					{
						$Config.mRendererLeft.setSize( w, h );
						$Config.mRendererLeft.setViewport( 0, 0, w, h );
						$Config.mRendererLeft.mViewport = new SoyRect( 0, 0, w, h );
					}
				
					if ( $Config.mRendererRight )
					{
						$Config.mRendererRight.setSize( 0, 0 );
						$Config.mRendererRight.setViewport( 0, 0, 0, 0 );
						$Config.mRendererRight.mViewport = new SoyRect( 0, 0, 0, 0 );
					}
				}
				
			}


var gDepthNear = false;
var gDepthFar = false;
var gPointSize = false;
var gPositionScalar = false;
var gWorldYaw = false;
var gPointCloud = null;

			function Animate($Config) {

				requestAnimationFrame( function(){Animate($Config);} );
				
				$Config.mDebugCameraControls.update();
				
				//	update shader constants
				var $PointCloud = gPointCloud;
				if ( $PointCloud )
				{
					var $Uniforms = $PointCloud.mAsset.material.uniforms;
					
					if ( gDepthNear === false )	gDepthNear = $Uniforms.gDepthNear.value;
					if ( gDepthFar === false )	gDepthFar = $Uniforms.gDepthFar.value;
					if ( gPointSize === false )	gPointSize = $Uniforms.gPointSize.value;
					if ( gWorldYaw === false )	gWorldYaw = $Uniforms.gWorldYaw.value;
					
					$Uniforms.gDepthNear.value = gDepthNear;
					$Uniforms.gDepthFar.value = gDepthFar;
					$Uniforms.gPointSize.value = gPointSize;
					$Uniforms.gWorldYaw.value = gWorldYaw;
					$Uniforms.gDepthNear.needsUpdate = true;
					$Uniforms.gDepthFar.needsUpdate = true;
					$Uniforms.gPointSize.needsUpdate = true;
					$Uniforms.gWorldYaw.needsUpdate = true;
				}
				
				if ( gPositionScalar === false )	gPositionScalar = $Config.mPositionScalar;
				$Config.mPositionScalar = gPositionScalar;

				Render($Config);
			}

			function Render($Config) {

				var timer = 0.0001 * Date.now();

				//	update camera
				var Quaternion = GetCameraQuaternion();
				$Config.mCamera.quaternion.copy( Quaternion );
				var $Position = GetCameraPosition();
				$Config.mCamera.position.copy( $Position );
				$Config.mCamera.position.multiplyScalar( $Config.mPositionScalar );
				
				var QuatDebugElement = GetElement("QuatDebug");
				if ( QuatDebugElement )
					QuatDebugElement.innerText = $CurrentCameraControl + ": " + Quaternion.x + " " + Quaternion.y + " " + Quaternion.z + " " + Quaternion.w;
				
				var $PosDebugElement = GetElement("PosDebug");
				if ( $PosDebugElement )
					$PosDebugElement.innerText = $CurrentCameraControl + ": " + $Position.x + " " + $Position.y + " " + $Position.z;
				
				onContainerResize( $Config );
				
			
				if ( $Config.IsSplitEnabled() )
				{
				//	$Config.mSplitter.setSize( w, h );
					$Config.mSplitter.render( $Config.mScene, $Config.mCamera );
				}
				else
				{
					var $Camera = $Config.mEnableDebugCamera ? $Config.mDebugCamera : $Config.mCamera;
					
					if ( $Config.mRendererLeft )
					{
						$Config.mRendererLeft.render( $Config.mScene, $Camera );
						$Config.mRendererLeft.mLastCamera = $Config.mCamera;
					}
					
					if ( $Config.mRendererRight )
					{
						$Config.mRendererRight.setSize( 0, 0 );
						$Config.mRendererRight.setViewport( 0, 0, 0, 0 );
						$Config.mRendererRight.mLastCamera = null;
					//	$Config.mRendererLeftRight.render( $Config.mScene, $Config.mCamera );
					}
				}
				
			}
	
	function LoadPointCloud($Asset,$Config)
	{
		if ( $Asset.mMeta.Format != 'GsvPointCloud' )
			return false;
		gPointCloud = $Asset;
		$Config.mScene.add( $Asset.mAsset );
	}

		function UpdateTexture($Asset,$Config)
		{
			//alert('update texture');
			if ( $Config.mRenderMode == RENDERMODE_CSS )
			{
				for ( var $Key in $Config.mRenderCubes )
				{
					//	gr: this log makes it display :/
					//console.log("set cubes",$Config);
					SetCubemapBackground( $Asset, $Config.mRenderCubes[$Key] );
				}
			}
			else
			{
			//	console.log("Update texture", $Asset,$Config);
				//console_logStack();
				var $Material = $Config.mMesh.material;
				
				//	already assigned to this asset, so just update it
				if ( $Material.map.image == $Asset.mAsset )
				{
					//console.log("refreshing asset");
					$Material.map.needsUpdate = true;
				}
				else
				{
					//console.log("new texture");
					var $Texture = new THREE.Texture( $Asset.mAsset, new THREE.UVMapping() );
					$Texture.generateMipmaps = false;
					$Texture.minFilter = THREE.LinearFilter;
					$Texture.magFilter = THREE.LinearFilter;
					$Texture.needsUpdate = true;
					
					$Material.map = $Texture;
					$Material.needsUpdate = true;
				}
			}
			
			return true;
		}

		//	save initial mode
		PushMode();
		
		//	init support
		AddDefaultSupportAutoSwitch();
		
		InitSupport();
		
		
		//	todo: load pano, if meta ONLY supports cubemap, we need cubemap mode. same with videos...
		
		
		//	setup config
		var $RenderMode = RENDERMODE_NONE;
		
		if ( HasHashParam('cubemap') && IsSupported('Css3d') )
		{
			$RenderMode = RENDERMODE_CSS;
		}
		else if ( IsCanvasSupported() && IsSupported('Webgl') )
		{
			$RenderMode = RENDERMODE_WEBGL;
		}
		else if ( IsCanvasSupported() && IsSupported('Css3d') )
		{
			$RenderMode = RENDERMODE_CSS;
		}

		var $Config1 = new SoyConfig( $RenderMode );
		$Config1.mContainer = GetElement("container");
		$Config1.mOnNewFrame = function($Asset) { UpdateTexture($Asset,$Config1) };
		$Config1.mOnNewOtherAsset = function($Asset) { LoadPointCloud($Asset,$Config1); }

		var $Mouse = GetSupport('Mouse');
		if ( $Mouse )
			$Mouse.SetContainer( $Config1.mContainer );
	
		if ( HasHashParam('border') )
			Debug_SetStyleBorder($Config1.mContainer);
	
		if ( $Config1.mRenderMode != RENDERMODE_NONE )
		{
			InitWebgl( $Config1 );

			//	load user's required pano
			LoadPano( $Config1 );
			$Configs.push($Config1);
			
			
			//	make a second config
			if ( HasHashParam('dual') && GetElement("container_dual") )
			{
				var $Container2 = GetElement("container_dual");
				if ( HasHashParam('border') )
					Debug_SetStyleBorder($Container2);

				$Config1.mContainer.style.bottom = '50%';
				$Container2.style.top = '50%';
				
				var $Config2 = new SoyConfig( RENDERMODE_CSS );
				$Config2.mOnNewFrame = function($Asset) { UpdateTexture($Asset,$Config2) };
				$Config2.mContainer = $Container2;
				InitWebgl( $Config2 );
				LoadPano( $Config2 );
				$Configs.push($Config2);
			}
			 
		}
		else
		{
			ShutdownSupport();
			Container.style.padding = "20%";
			Container.innerText = "Not currently supported without webgl or css3d.";
			
		}


		if ( HasHashParam('menu') )
		{
			forEach($Configs,function($Config) { RegisterMenuConfig($Config); } );
			
			
			
			var $WelcomeDom = document.createElement('div');
			$WelcomeDom.innerHTML = 'welcome<br />to<br />panopo.ly';
			$WelcomeDom.style.backgroundColor = 'white';
			var $WelcomeMenu = new PanoMenu($WelcomeDom);
			$WelcomeMenu.Show();
			setTimeout( function(){$WelcomeMenu.Hide();}, 2* 1000 );
			
			//ShowMenu("hello!");
		}

	</script>

	</body>
</html>
